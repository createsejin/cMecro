24-01-24-007
    홀드키와 일반키가 서로 다르게 저장되서.. 수정해야함.

24-01-25-000
    단일 홀드키에 대해서만 분리하고, 또한, 블로킹 여부에 따라서는 분리해야함.
    그 이외에는 사이즈 2이상인 홀드키랑 기본 NORMAL 패턴은 서로 합치는게 좋을듯 함.
    그리고 토글 패턴도 그냥 합치면 될듯함. 토클은 작동 방식은 노멀이랑 다를바가 없고, 그냥 bool형
    데이터를 하나 더 가지는것 뿐임. 그런데 단일 홀드키는 조금 다른 방식으로 작동함. 사이즈 2이상 홀드키는 그냥
    타이머가 거의 필요가 없음. 물론 타이머가 필요한 경우는 중복된 패턴이 있을때. 예를들어 다음과 같을때임
    h{X, C}, V
    h{X, C}, V, B  뭐 이런 경우에는 타이머가 필요함.
    근데 단일 홀드키는 반드시 press 기준의 타이머가 작동해야 올바르게 작동할 것임.
    그리고 타이머가 타임아웃되면 홀드키를 조사해서 그 홀드키에 맞는 패턴 동작을 실행하게 하면 된다.
    근데 솔직히 단일 홀드키든 뭐든간에 그냥 다 합치는게 맞는것 같음. 일단은 사이즈 2 이상 홀드키랑 노멀키는 무조건
    합치는게 맞음. 솔직히 단일 홀드키도 뭐 따로 분리하는것도 좋은데.. 흠. 일단은 사이즈 2 이상 홀드키랑 노멀키 합쳐보자.
    그 다음에 단일 홀드키를 작업하든가 하자. 그리고 나중에 토글키는 bool을 어디에서 데이터를 저장하고 컨트롤할지도 생각해야함.

24-01-25-001
    그을쎄다. 아마도 필요한건 key_patterns_block이랑 non-block 두개로 통일하는 일임.

24-01-25-002
    그런데 홀드키 필터는 어떻게 할까.. 근데 홀드키 필터는 분리하는게 맞음. 왜냐면 예를들어 더블 사이즈 홀드키는 그 홀드키의 모든
    패턴비트를 전부 섞어야함. 그러니까 더블 홀드키랑 싱글 홀드키는 작동 방식 자체가 아예 틀리다. 차라리 이걸 더 명확하게
    분리하는게 나아보임. 그러면 단일이랑 더블 홀드키의 필터는? 근데 그거는 그냥 같은거로 봐도 되지 않을까.
    근데 분리해야하는 이유는 단일 홀드키가 눌린걸 감지해야하기 때문임.

24-01-25-003
    일단은 단일 홀드키 만들기 전에 더블 홀드키랑 노멀키 잘 작동하는지 테스트를 하자.

24-01-25-004
    그 특수키 누를때 따로 공유 변수를 둘거야. 예는 아토믹으로 놓고 쓸거고. 엔터키가 떼어지더라도 동작하는 중간에
    바뀌지 않는 변수임. 이렇게 하면 엔터키가 뗀 시점에 관계 없이 제대로 프로세스가 동작 할거야.

24-01-25-005
    지금 check_hold_key_press에 hold_key_patterns가 들어가 있어서 이상하게 동작함.
    아닌데.. 뭐가 문제일까.. 아 그러니까 이게 예를들어서 XC랑 XC_B가 있으면 첫번째 XC만 적용되서 B가 안들어갔네.
    그러니까 이런 경우에는 while문에서 break 하는게 아니라 그냥 루핑을 돌면서 매치되는 패턴이 있으면 그 패턴 역시 전부
    필터에 or연산 해야한다는 거네.. 일단 다시 테스트 해보자.
    뭔가 이상하다. 필터가 갱신이 안된다. 도대체 뭐가 문제인가. filterd_key_state와 current_pattern_bit을 debug 출력하고
    테스트 해보자. 알고 보니 아까 초기화 메소드에서 hold키에 대한 key_patterns 벡터를 아예 초기화를 안했다.
    즉 여기에는 아무것도 들어가지 않은것. 다시 고치자.

24-01-25-006
    그러니까 initialize_current_resources에서 처음 초기화 할때 핵심은 논블로킹이랑 블로킹 일단 나누고, 그 안에서
    만약 홀드키 있다면 홀드키도 논블록, 블록 나눠서 넣어주고 그냥 key_patterns_block이랑 논블록에는 전부 집어넣어주면 된다.

24-01-25-007
    아마도 check_hold_key_press에서 처음에 current_key_filter를 초기값으로 초기화 해주는게 필요해보임.
    그리고 문제점이 하나 더 발생했다. 예를들어서 X, C를 누를때, 먼저 X가 들어오고, 아마도 처리되는 시간이 문제인건지 X랑 C가 서로 따로
    처리되서 들어온다는것이다. 그렇다면 이걸 key struct의 시간을 기준으로 해야할수도 있다는 건데.. 흠.
    그러니까 이게 문제가 될 수 있다는 것이다. 왜냐면 키 프레스간 사이에 여러가지 연산이 들어가니 당연히 시간이 지연되는 것이다. 아마도
    이걸 시간을 재보던지 해야할 수도 있음. 아니면 다른 방법으로는 key_bit_queue를 통해서 이걸 수행하는거임. 그렇게 하면.. 근데 그렇게
    하더라도 순차 실행이라 뭐.. 아니면 최후의 방법으로는 스레드를 쓰는 방법도 있겠지..

24-01-25-008
    설계 자체를 변경해야할 수도 있음.. 지금 이 방법으로는 오버헤드가 너무 심함. current_filter를 그냥 처음부터 확장을
    해 놓으면 되는거 아니냐고. 왜냐면 이런식으로 press할때 전부 홀드키 루핑해버리면 key press 시간이 서로 안맞게 되는 경우가
    생긴다는 거임. 만약 이걸 쓰려면 이렇게 체크하고 exit_method할 때까지 시작과 끝 시간을 계속 연속으로 이어 갈 수 있도록
    시간 찍는 타임과 그 찍은 걸 별도로 저장해서 진행해야함. 안그러면 이게 복잡한 과정이라 32ms안에 처리가 안되는 경우가 수두룩해짐.
    아니면 그냥 애초에 홀드키가 있으면 그 키 필터를 그냥 쭉 펼쳐주면 해결됨. 솔직히 이렇게 하는게 맞다고 본다.
    근데 그럴거면 단일 홀드키는 어떻게 처리할건데? 단일 홀드키는 반드시 키 press 단에서 패턴 매칭하는게 필요한데? 그러니까 이게 필요할
    수 밖에 없는것이라는 거임. 아니면 그냥 따로 홀드키만 처리하는 스레드를 만들어서 하면 스레드에서 detech하면 실행 시간은 단축 시킬 수
    있지. / 그러나 내 생각에는 그냥 이것은 아예 처음부터 키 필터를 더블 홀드키든 싱글 홀드키든 있으면 더블 홀드키의 모든 패턴으로
    처음부터 확장시켜놓고 그냥 exit 해주면 될것 같고, 어차피 싱글 홀드키는 타이머가 지난 이후에 따로 체크하면 되니까 press할때
    일일히 이런식으로 눌리는 키마다 패턴매칭을 할 필요는 전혀 없어보인다. 이렇게 하면 key_bit_queue push할때 오버헤드가 거의
    없을 것이다. 그리고 어차피 싱글 홀드키도 타이머의 타임아웃 됐을때 체크하는 거라 모든 키 눌릴때 마다가 아니라, 타임아웃때만
    체크하는거니까 그렇게 하는게 좋을 것 같다.

24-01-25_009
    그냥 첫 필터를 블록, 언블록으로만 나누고, 홀드키인 경우에는 combine key를 순회하면서 필터에 전부 추가해버림. 테스트 ㄱ
    아마 잘 될거다.. 근데 항상 테스트는 나의 예상을 항상 뒤엎지. 뭐 그래도 이번에는 잘 되는것 같은데.. 흠.

24-01-25_010
    이제 단일 홀드키에 대한 로직을 만들어주자. 일단 기본적인 설계 방향은 press때 타이머를 돌려서 타이머가 타임아웃되면
    그때 단일 홀드키에 대한 패턴만 확인하고 그 패턴이 확인되면 그 패턴을 실행시키는거지. 근데 문제는 그 동안에 패턴키가 모두
    릴리즈 되어버리면 그때에는 pattern_matcher가 실행될거고, 만약 첫번째 confirm의 결과가 false라면 그때에도 타이머가 돌아감.
    아니 그러니까.. 만약 press해서 타이머를 했을때에는 confirm을 동작시키면 안되지. 단지 hold키에 대한 부분만 확인하도록 해야
    하니까. 타이머는 동일한 이 타이머로 쓰면 되는데 로직을 서로 분리해야한다는 거지. 홀드키 press때 timer 동작 부분과 모든 패턴키가
    떼어지고 confirm action이 false일때의 타이머 로직과 서로 분리해야한다고. 일단은 단일 홀드키에 대한 구분된 key_patterns
    벡터가 필요해보인다. 이것 역시 블로킹, 넌 블로킹 나눠야 할듯. 그냥 처음에 만든걸 활용해야할것 같다. 그러니까 싱글 홀드키에 대한
    블록, 넌 블록 버전의 키 패턴즈 벡터와 키 필터가 필요하다는 뜻이다. 이름을 좀 수정해야겠군.
    single_hold_key_patterns_block, first_single_hold_key_filter_block 이런식으로 수정했다.
    메소드 이름도 수정해주자. 얘네들에 대한 get 함수가 필요할지는 만약 이것들이 외부 객체나 함수에서 쓰면 모를까, 내부 메소드만으로
    구현할거면 get 함수는 없는게 낫다. 일단은 두자고.
    패턴 매쳐를 활용할 수 있을까. 흠흠. 일단 패턴 매쳐는 기본적으로 key_bit_queue에 들어있는 애들을 가지고 하는건데..
    여기에서도 current_filter를 쓰고. current_key_paterns를 쓰지. 그것을 홀드키가 확인됐을때 갱신해주면 패턴 매쳐를 활용할 수도
    있을 것이다. 패턴매쳐를 재활용해야하는게 맞다. 어차피 홀드키도 어쨌든간에 패턴을 매치시켜서 그 명령을 해야하기 때문임.
    그리고 싱글 홀드키는 말 그대로 싱글이기 때문에 패턴 매쳐에서 {{X, C}, V}, {X, C} 문제도 신경 쓸 필요가 없음.
    전부 싱글 combine key 패턴이기 때문. 일단 지금의 pattern_matcher를 보면..
    일단 exit에서 처음에 필터와 매치되지 않는 키들은 무시함.
    그리고 또다시 current_key_filter를 이용해서 만약 이 필터키 중에 하나라도 눌린 경우에는 또 함수를 종료하게 해서
    마지막 패턴키 릴리즈때 매쳐가 실행되도록 하고 있음. 일단 이것이 문제가 될듯. 이것을 조건부 bool을 하나 걸어서 넘어하게 하거나
    해야할듯. 그 다음에는 이미 앞서 push_key_struck에서 여기에서도 current_filter에 의해 필터링된 키 bit들이 입력된
    key_bit_queue를 루핑하면서 매칭을 하고 있음. 매칭하는 패턴은 current_key_patterns_vec인데.. 이걸 이제
    싱글 홀드키의 key_patterns를 current에 갱신해주면 될 것으로 보임. 그리고 마지막으로 패턴이 매치되서 next에 하나라도 들어갈
    경우에는 이걸 다시 current_key_patterns_vec에 갱신해주고 이걸 confirm에서 확인하고 마지막으로 combine_key_bit_queue가
    empty한걸 매치해서 action을 실행하도록 되어있음..
    아마도 hold키가 눌렸을때에 대한 bool 변수를 반드시 하나 만들어서 그걸 가지고 로직을 구분하던지 해야 pattern_matcher를
    재활용 할 수 있을 것 같은데.. 쉽진 않아보인다. 아니면 pattern_matcher의 일부분을 따로 내부 메소드로 만들어서 그 부분만
    재활용하는 방안도 생각해볼 수 있을듯. 근데 싱글 홀드키라고 해서 특별히 다를건 없음. 진행되는 로직은 기존 매쳐와 거의 동일하다.
    일단은 press때 타이머를 돌리는걸 해야할듯. 아마도 누를때 마다 현재 눌린 시간을 타이머에 갱신해야할듯.
    그래야 다른 키가 눌릴때 다시 그 시간 기준으로 타이머에서 계산하도록 하는거지. 근데 이게 기존의 키 릴리즈에서 패턴 매쳐에 의해
    실행되는 타이머와 구분되는건지 이게 실행해도 되는건지는 테스트를 좀 더 해봐야 알 수 있을듯.

24-01-25_011
    일단은 press때 타이머를 동작시키게 코드를 짜보자. 근데 그 전에 single hold key first filter를 초기화 하는 코드도
    만들어야지. 대충 만들었다. 이거도 역시 테스트를 해서 제대로 잘 들어갔는지 확인하는 작업 한 번 쯤은 해두면 좋을 것 같다.
    아니 이건 무조건 확인해야하는 작업이다. 번거롭더라도 테스트 코드를 작성 해야한다.
    이거 테스트 코드 작성할때 나중에 또 사용할걸 고려해서 재사용 가능하게 key_patterns vector를 출력하는 부분. 이건 이미
    만들어두었으니, key_filter를 출력하는 메소드를 하나 만들면 될 것 같다.
    일단은 테스트 결과 제대로 다 들어가는걸 확인함.
    나중에는 이렇게 패턴 입력하고 init 할때 패턴끼리 서로 배타적인 것들 있는지 거르는 검사 코드 반드시 만들어야함.
    이게 없으면 무법 그 자체. 프로그램이 내 의도대로 동작하지도 않을듯. 일단은 이제 다시 싱글 홀드키 press timer 로직을 만들자.

24-01-25_012
    일단은 기본적인 로직은 press할 때마다 타이머 time point를 갱신해주고 timer를 start시킴. 그리고 timeout이 되면
    current_key_patterns는 single_hold_key_patterns_non_block으로 갱신해주고 current_key_filter도
    first_single_hold_key_filter_non_block으로 갱신. 근데 만약 is_proceed_blocking_key_process가 true인지 아닌지도
    구분해서 갱신해야지. 어차피 논 블로킹 부분은 철저하게 분리해서 패턴 매칭할거라 그건 의도대로 구현하면 됨.
    그리고 타임아웃이 되면 그때에 이런 애들을 불러와서 pattern_matching을 진행해주면 될듯. 일단은 key_state를 여기에서도
    활용을 해야할것이고 당연히 필터링하는건 필수지. 일단은 press 될 때마다 time point 갱신해주는건 기존
    pattern_matcher에서 set_last_release_time_point 부분과 유사함. 일단은 timer의 동작은 매우 간단한데,
    기존에 만들었던 로직하고는 분명히 구분해야함.

24-01-25_013
    push_to_key_bit_queue에서 exit 이걸 통과한 다음에 press time을 set하게 하면 될것 같음.
    어차피 처음에는 첫 필터에 의해 exit가 되고. 특수키 눌려져도 자동으로 갱신되서 필터링하는거라 괜찮을듯.
    그전에 근데 특수키 패턴은 잘 작동하는지 테스트가 필요해보임. 일단 단일 홀드키 빼고 테스트해봐야지. 아마 잘 될건데.
    잘 되는구마 뭐. 다 내가 알아서 잘 설계 했다니까.

24-01-25_014
    그런데 push_to_key_bit_queue에서 exit 이후에 이미 set_current_key_time_point가 있네. 이걸 이용하면 구지
    따로 last_press_time_point 설정할 필요는 없어보임. 그렇게 하면 오버헤드가 없어지고.
    그런데 이걸 서로 분리해서 하는게 맞을까. 예를 들어서 timeout 변수를 공유하는게 맞을지 모르겠음. 아마 나누는게 나을듯 한데.
    왜냐면 이건 확실히 구분해야함. release에 의해서 timeout이 된건지, hold key press에 의해서 timeout이 된건지는 구분을
    해야한다는 것이다. timer_active는 공유해도 될것으로 보이는데.. 흠. 역시 그냥 나누는게 맞는것 같다. 그리고
    pattern_matcher에서 현재 패턴을 매칭하는 부분만 따로 떼서 hold_key 어떤 패턴이 매치됐는지 검사해주면 될것 같다.
    어차피 단일 홀드키라 패턴은 하나밖에 없다. 구지 key_bit_queue를 통해 여러 패턴을 조사할 필요는 없다는 것임.
    일단은 되도록이면 pattern_matcher를 재사용하도록 코드를 짜야하는데..
    일단은 기존대로 key_bit_queue를 이용해야할것으로 보인다.. 흠. 근데 이미 누를때 key_bit_queue에는 키들이 들어가있잖아.
    예를들어서 {X, C}를 눌렀다면 이미 그건 key_bit_queue에 잘 들어가있다는 것이다.
    그 상태에서 press에 대해서 timer에 current_key_press_time_point를 갱신해주고 timer가 time out이 될때
    패턴 매쳐를 부르면 되는건데.. 패턴 매쳐에서는 단일 홀드키에 대한 매칭을 진행하는것이고..
    그런데 이때에는 조금 다른 바레이션이 필요하다. 일단 timeout이 된 사실을 pattern_matcher에 알려줘야한다는 것이고,
    pattern_matcher의 실행을 중간에 멈춰버리는 애들을 패스하게 해줘야한다는 것임. 그런데 exit는 어떨까. 상관 없지 않음?
    어차피 단일 홀드키도 current_key_filter를 통해서 필터링되는거고. 중요한것은 current_key_patterns랑
    current_key_filter를 단일 홀드키 세트로 갱신해줘야한다는 것이다. 그 갱신을 타임아웃이 되었을때 해줘야한다는 것이고.
    근데 pattern_matcher의 두번째 저지 지점인 현재 필터의 키중 하나라도 눌려있으면을 하는 이거. 이거는 패스 해줘야함.
    왜냐면 홀드키라는건 계속 눌린 상태거든. hold_key_press_time_point get 함수 하나 만들어야겠다.

24-01-25_015
    pattern_manager에서 이제 timeout 되면 내부적으로 current를 hold key로 갱신해주는 메소드 하나 필요해보인다.
    근데 진짜 pattern manager는 이제 좀 많이 커졌네 ㅋㅋ 좀 나누면 좋을것 같긴 한데 진짜 애매하게도 key pattern에
    대한 거의 모든 기능을 다 맡아버리고 있다. ㅋㅋ 아무튼 나중에 key pattern sql로 입력받을건데 그때에도 이거 쓸거임? ㅋㅋ
    근데 그때에는 진짜 분리해서 그 결과를 pattern manager에 넘기는 방식으로 해야할듯. 아무래도 지금도 뭔가 나누면
    좋을것 같은 것들이 없진 않아보이는데.. 내 생각에는 pattern_matcher는 따로 분리 하는게 낫지 않을까 싶기도 함.
    그러니까 내 생각은 pattern_manager의 역할은 그냥 pattern들의 vector나 filter를 관리해주고 그걸 다른 객체에서
    쓸 수 있게 만들어주는 정도만 하는거임. pattern을 match 시키는 업무는 다른 객체에서 하는게 좋지 않을까 싶기도 함.
    여기서 보면 몇 개 그런게 보이잖아. 그러니까 pattern_manager의 역할을 한 가지로 축소하는거임. 단일 책임 원칙을
    지키는 것이기도 하고. 좀 분리하는게 좋아보인다 내가 봐도. 근데 key_patterns.cpp/.h에 전부 구현할거임?
    뭐 나눠도 되는데 구지? 그냥 여기에다가 박아도 그닥 상관 없을듯.

24-01-26_000
    단일 책임 원칙을 위해서 클래스 pattern_matcher 기능을 분리하고 있다. 유지보수 측면에서도 좋아질듯. 옮기다 보니
    current 관련된 부분도 분리되고, ininitialize도 분리할 수 있으면 그렇게 하는게 더 좋아 보였다.
    decide_current_key_patterns_vec 메소드 분리하고 있었음. 자고 있다가 다시 하자.

24-01-26_001
    새벽에 했던거 마저 하자. 그리고 얼른 단일 홀드키 구현해야지. 일단은 PatternMatcher 클래스에 옮기는 작업은 다 했으니
    이제 필요 없는것들 싹다 정리해버리고 깔끔하게 만들어버리자. 작동 잘 되는지 테스트 해봐야함. 빌드도 해봐야하고.

24-01-26_002
    또다른 문제가 생겼다. 문제는 Press 시간을 기준으로 hold key의 press를 재는 타이머에서 타임아웃이 발생해서 만약
    기존의 X, C 노멀키 같은걸 입력해버리면 릴리즈된 시점 기준으로는 무조건 hold key press 타임아웃이 먼저 발생해버려서
    release 타임아웃은 아예 실행되지 않는 것이라는 것이다. 어쩌면 다른 방법으로는 아예 타이머 스레드를 두 개 만들어서 운영해
    버리는 것도 생각할 수는 있겠다. 어차피 두 타이머는 철저하게 분리하는게 맞으니까. 그런데 분리를 안하고 할 수 있는 방법은
    없을까.. 아니면 그 전에 패턴 매칭을 해서 홀드키가 눌려졌을때에만 타임아웃되게 하면 되지. 일단 프레스키에 대해서 시간은
    계속 재는거고. 타이머를 종료시키는 시점을 홀드키가 눌려져서 매치됐을때로 하면 되지. 어차피 타임아웃 변수로는 타이머를
    멈추는건 아니니까 타임아웃된것만 알리고. 근데 구지 타임아웃 변수 필요 없을 수도 있는데 아무튼.
    timer_active를 홀드키 매치되면 false로 하면 되지. 이것만 적절한 시점에 제어하면 타이머는 홀드키가 눌리지 않는 이상
    멈추지 않음.

24-01-26_003
    흠.. 일단은 얼른 단일 홀드키에 대한 로직을 만들어야한다. 기본적으로는 current_key_patterns_vec와
    current_key_filter를 단일 홀드키 전용으로 갱신 한 후에 pattern_matching을 호출하고 confirm 까지 해야됨.
    만약 매칭된게 있으면 그때 타이머를 멈추면 될듯. 어차피 계속 눌린 상태에서 명령이 실행되는거라 그 이후에 만약
    릴리즈 되면 그때에도 타이머가 돌아갈텐데 그때에는 그렇게 하면 안되지. 릴리즈 되더라도 타이머를 진행 시키면 안됨.
    근데 홀드키 듀레이션도 체크하긴 해야해. 어차피 이건 디버그 출력문을 보면서 결정해도 되니까 그렇게 하자.

24-01-26_004
    그런데 문제는.. 만약 press에 의해 timeout이 되서 current 패턴이랑 필터가 바뀌어버리면.. 그럼 릴리즈때는
    그걸 다시 갱신해야하는데? 진짜 애매하네 .. 근데 어차피 홀드키를 눌렀다면, 릴리즈는 나중에 하니까. 뭐 상관은 없을텐데
    문제는 홀드키를 빨리 떼면 또 릴리즈 기준으로 timeout되어 confirm 할텐데.. 아무튼 그걸 잘 제어해야할듯.
    홀드키가 눌린 경우에는 릴리즈 되더라도 타이머를 멈추게 하던가 아니면 거기에서 뭐 함수를 종료하게 하던가 해야할듯.
    만약 매치가 되거나 매치가 안되더라도 다시 current를 초기화 해야한다는 것임. 근데 current 초기화 하는거는 어차피
    pattern_manager에서 이미 잘 분류된 벡터랑 비트셋 있어서 초기화 하는건 전혀 문제 될게 없음. 그러니까 그냥
    current 가지고 패턴 매칭 하면 된다 이거야. 다시 만들자. 아 그리고 홀드키 누른 시점에서는 이제 key_bit_queue에
    이미 키들이 들어왔으니 그대로 그걸 활용하면 된다. 그러니까 그냥 pattern_matching 이걸 바로 사용하면 된다는거임.
    단지 해줄건 선행적으로 단일 홀드키에 대한 current 리소스만 갱신해주면 된다는거임.

24-01-26_005
    음.. pattern_matching을 optional로 만들어야겠누.. 아니면 그냥 함수 오버로딩해도 상관은 없어보임. 공통 부분만 추려서.
    근데 그거보다 그냥 optional 쓰는게 여기에서는 바람직해보임.

24-01-26_006
    그냥 타이머 따로 하는게 맞는듯. 같이 멈춰버리면 전혀 예상치 못한 동작이 일어날 가능성이 언제나 생긴다.
    그리고 press때마다 타이머 계속 돌리는 코드도 필요하고. 만약 매치되지 않았을때 타이머 멈추는것도 필요하고.
    매치 됐을때에도 타이머 스톱해야하고. 그럼. 그리고 지금 너무 pattern_matching 이거 커지는데.
    그냥 함수 오버로딩으로 아예 그냥 나누는게 나아보임. 그리고 key_press때 마다
    press 시간은 갱신하는건 좋은데. 이걸 만약 매치되는게 없으면 타이머를 멈출지 말지도 결정해야지.
    근데 멈추는게 맞아보임. 어쨌거나 타임아웃 됐는데도 매치되는게 없는데 타이머를 계속 돌릴 필요는 없고.
    어차피 다음 press때 다시 돌리면 되니까. 어쨌든 타이머 스레드 서로 분리해서 따로 돌리는게 맞다.
    근데 이러면 스레드가 대체 몇 개냐. 키보드 마우스, 타이머 스레드 두 개, 명령 실행 스레드 한 개
    총 5개네? ㅋㅋ 일단은 타이머도 따로 만들어줘야할듯.

24-01-26_007
     타이머 서로 나누려면 타이머 클래스 싹다 재개편 해야함. cv도 따로 만들어야할듯.. 개편은 했는데 문제는
    press 때마다 이걸 돌리는건 좋은데 문제는 타임아웃 될 때마다 current를 초기화하는건 좀 아닌듯.
    그냥 press때에는 current가 아니라 그냥 pattern_matching을 좀 다르게 설계해야겠다.
    일단 key_bit_queue는 그냥 필터링해서 쓰면 됨. 문제는 current는 다른걸로 써야함. 안그러면 release에서
    이게 잘못될 가능성이 있음. 그냥 아예 분리하는게 맞다. 그러니까 프레스 할때마다 이건 무조건 타임아웃남. 그러면
    current가 거의 항상 싱글 홀드키로 초기화되는데 이 상태에서 키 릴리즈때 패턴매쳐 실행하면? 안돼.
    분리하는게 맞음. press time out때에는 무조건 싱글 홀드키만 검사하도록 해야함.

24-01-26_008
    근데 지금 보면 문제점이. 홀드키가 계속 눌려있는지 여부를 검사하는게 없잖아. 그러니까 일단 매칭을 시키고 confirm에서
    이게 눌린건지 검사해야지.

24-01-26_009
    confirm을 그냥 매개변수 받으면 해결되잖아. 결국 값이 있고 없고에 따라 optional을 써서 해결했다.

24-01-27_001
    타이머에서 pattern_matching을 계속 불러대니 문제가 터졌다. 또한 홀드키 프레스 후 릴리즈때에도 또 pattern_matching을
    호출하는것도 제어를 해야한다. 그리고 릴리즈때 홀드키가 떼어지면 pattern_matching을 호출하지 않도록하는데
    next 대신에 따로 키 패턴을 저장하는 멤버 변수를 지정해야할 것 같다. current_key_press_time이 갱신되지 않는것 같은데.
    그런문제가 아니였다. 문제는 key_bit_queue를 루핑하는데 pop을 안해줘서 무한루프가 발생한것.. 그냥 while이 아닌 if로
    바꿨다. 그리고 릴리즈때 홀드키에 대해서는 무시하는 코드를 짜야할 것 같다. 어차피 current_hold_key는 다음 press때
    초기화 되도 상관은 없으니 뭐.

24-01-27_002
    이전번에 눌렸던 홀드키에 대해 릴리즈 시 pattern_matching을 무시하게 코드를 짜려면.. 일단은 그 상황을 자세히
    들여다 봐야한다. 예를들어 x, c가 눌렸을때 하나씩 떼어질때 패스하게 하는것. 내 생각에는 current_hold_key에서
    key_pattern의 combine 키 bitset을 하나씩 0으로 reset해주는것. 그런데 이렇게 하려면.. 그전에 이전
    pattern_matching에서 combine_key_queue를 pop 시켰기 때문에.. 근데 pop 안시키면 되는거 아니냐.
    아니면 그냥 combine_vector를 쓰면 됨. combine_key_queue를 pop 시키는 이유는 confirm 때문임.

24-01-27_004
    어제 안됐던걸 어느정도 고쳤다. 문제는 타이머를 멈추는 수단이 없었다. 게다가 pattern_matching에 while문에서
    key_bit_queue가 not empty한데 while문 조건이 충족되서 무한 루프에 빠지기도 하였다. 게다가 릴리즈때 타임아웃
    되면 단일 홀드키가 매치되서 그 문제도 해결했다. 단일 홀드키는 confirm의 두번째 확인 조건에서 빼버렸다.
    이제 오늘은 이것저것 테스트 하고 토글키 만들고 마무리하면 될듯. 그리고 이제 action function도 만들고.
    send_input도 테스트하고. 그리고 그 릴리즈때 홀드키의 패턴이 실행되는건 이미 막혀있었다. 앞에 조건식에서
    패턴키가 모두 떼어져야 작동하는 부분에서 이미 처리된것. 그래서 구지 따로 구현할 필요는 없었다.
    그리고 부득이하게 패턴 매칭 메소드를 두 부분으로 나누었는데.. 솔직히 맞는지는 모르겠다. 아니면 중간 부분
    매칭하는것만.. 근데 이것도 나눠야하는게, 홀드키의 눌림을 확인하는 부분도 그렇고.. 홀드키때는 current를 쓰면
    교란되기 때문에 문제가 발생해서 아예 따로 홀드키 전용 벡터를 검사하도록 하였다.
    그리고 홀드키 부분도 조금 복잡했는데, 이것도 코멘트를 좀 달 필요가 있어보인다.

24-01-27_005
    그런데 만약 key_bit_queue에 두 개 이상이 입력되면 그때에는 어떻게 할건가? 예를들어 F, (x, c) 이렇게 눌렸다면?
    이러면 순차적으로 그렇게 들어올 것이다. 그러니 while문으로 하고 key_bit_queue를 pop 시키면 되지 않을까?
    아무튼 패턴 매칭 루핑이 끝나면 key_bit_queue를 pop 시켜주면 해결된다. 그러면 연속키 입력 후 홀드키 입력에도
    될것인데. 문제는 F, (X, C) 이렇게 한다고는 처도. 만약 (X, C), h(V) 이렇게 누르면 어떻게 됨? 근데 만약 이걸
    연속으로 누르면 key_bit_queue에 저렇게 그대로 추가될것이고. 앞에 (X, C)는 무시될것이다. 왜냐하면 (X, C)가
    릴리즈 됐다고 해도 만약 이게 (X, C), V 패턴 같은게 없다면 바로 (X, C) 패턴이 실행될것이다. 이것은 타임아웃에
    관계없이 매치되면 실행되니까. 근데 (X, C), V 패턴이 있다면 바로 실행되지 않을것이기 때문에 (X, C)는 무시된다.
    그런데 문제는 이렇게 하면 홀드키 패턴 매칭에서 (X, C)가 매치되버린다는 것.. 그러네. 아니다.
    왜냐면 매치된다해도 현재 key_state에서 눌렸는지 여부 역시 검사함. 그래서 (X, C)를 눌렀다가 바로 뗐다면 상관은
    없겠지. 아니 이게 바로 key_bit_push처럼 누를때마다 호출되는게 아니라, 누른 뒤에 press_timer가 time out 됐을때
    패턴매칭 진행하는거니까 상관 없는거다. 즉, 만약 (X, C)를 눌렀다가 바로 뗐다면 두번재 검사식에 의해 무효로 처리된다는것.
    그러면 다음으로 넘어가니까 된다. 그리고 X가 있다고 해도 (current_key_bit ^ current_pattern_bit).none() 이
    검사식은 반드시 전부 매치되어야만 되기 때문에 무시된다. 그건 이미 예상한 결과이고 의도대로 설계한것. 그러니 문제는 없다.

24-01-27_006
    그리고 이제는 패턴들에 대한 중복 검사라던가 유효성 검사를 만들때가 되었다. 일단은 토글키 먼저 구현을 해보자.
    토글키는 진짜 별거 없음. 그냥 key_pattern 클래스에 bool 하나 만들고 pattern_manager에서 관리하게 하면 됨.
    key_pattern 클래스에 관련된 bool이랑 set, get 만들면 되지. filp도 만듬. 토글은 bool을 뒤짚는 거니까.
    구현하고 테스트 진행 ㄱㄱ
    아 그리고 key_patterns.h랑 action_operator.h 에서 순환 참조 문제 때문에 Actions 열거형을
    따로 헤더를 만들어서 actions.h로 넣어서 분리해버림. 순환 참조 문제는 나도 몰랐는데 이런 경우가 있더라고..

24-01-27_007
    토글키 key_pattern을 따로 pattern_manager에 넣어서 그걸 컨트롤해야지. 그리고 특수키 누르고 나서 아무것도
    매치되지 않을때 초기화 되지 않는 문제 있음. 그리고 function map은 따로 테스트 하야할듯..
    그리고 왜 key_pattern execute action에서 안되는건지도 알아봐야함.

24-01-27_008
    일단 토글키 구현과 action operate 구현도 어느정도는 됐다. action 스레드 따로 만들어서 해야할듯..

24-01-27_009
    일단 엔터키 이슈 해결해야함. 그냥 엔터키 눌렀다 뗄때, 엔터키랑 넌 패턴키 섞어 칠때, 그리고 각 패턴 전부 테스트 검사해야함.

24-01-28_000
    엔터키 이슈 아직 미해결. 이제 그냥 눌렀다 뗄때 초기화는 잘되는데.. 문제는 엔터+싱글 홀드키가 작동을 안한다. 아마도 엔터키가
    계속 눌려있어서 이게 필터 뭐 어쩌구 때문에 안되는듯. press timer가 돌아가야하는데 이것도 안돌아가고. 어쨌든 이 문제도
    해결치고 이제 테스트를 좀 빡시게 돌리고 SQL 이랑 패턴 유효성 검사 만들어야지. release 타이머에서는 어쨌거나 단일
    홀드키는 아예 취급을 안해서 소용이 없고. press timer를 작동시켜야하는게 엔터키가 문제였던것.

24-01-28_001
    블로킹키가 이상하게 먹어서 하나 수정해줬다. not을 안해줬던것..

24-01-28_002
    아니 왜 필터가 안먹음? V도 들어와야하는데? 필터가 이상했구만. 엔터 누를때 패턴 바뀔때 뭔가 이상했음. 필터 초기화 하는 부분
    에서 다시 적절하게 섞어야할듯. 단일 홀드키도 같이 섞어야하는데.. init을 수정해야겠다. 그게 아니라 V hold키를 블록키에
    추가 안했잖아.

24-01-28_003
    아 그리고 이제 Actions, action_function_map, key_patterns 각각의 관점에서 서로 어떤 action들이 누락되어있는지 검사하는
    부분을 어느정도 완성했다. 다음에는 action_function_map에서 중복된 항목이라던가 Actions는 어차피 열거형이라 누락되거나 중복
    되면 알아서 컴파일러가 거르니까 상관 없고. key_patterns 유효성 검사를 추가해야할 것 같다.

24-01-28_004
    아 그리고 이제 블로킹 상태에서 V 홀드키를 누르고 뗄때 엔터에 의해 release timer가 여전히 돌아가서 confirm을 해버린다는게
    문제가 생겼다는점. 그걸 막아야한다. 구지 confirm을 부를 필요가 없어. 그러니까 이게 엔터키 릴리즈때 무조건 타이머를
    부른다는게 문제임. 릴리즈때 타임아웃이 되는데 이 타임아웃에 의해 confirm이 불려지는것. 그리고 엔터키에 의해 current는
    블로킹 키 패턴 셋으로 바뀌거든. 그걸 이제 그대로 confirm 한다는 것인데.. 어쨌든 pattern_matching은 불려지지 않음.
    엔터키 릴리즈 때문에 그럼. 필터링 되거든. 키 릴리즈때 confirm을 부르는 조건을 추가하던지 해야할듯.
    그러니까 이때의 목적은 key_bit_queue에 아무것도 매칭되지 않을때에도 엔터키 릴리즈에 의해 리소스를 재 초기화하는게 목적임.
    그러니까 어찌됐던간에 confirm에서 true를 반환하든, false를 반환하든 release time out이 됐으면 무조건 리소스를
    초기화하는게 맞음. confirm은 current_vec을 확인해. 그 일은 불필요하다는 것이다. 그렇다면 key_bit_queue가 비어있는지
    조사하면 되는거 아니냐고. 만약 비어있으면 confirm을 호출하지 않도록 하는거지. 그러니까 이런 패턴이 pattern_matching에서도
    똑같이 적용되는데, 여기에서도 key_bit_queue가 비어있으면. 그러면 keyboard_hooker단에서 이걸 처리하는게 어때?
    엔터키가 릴리즈 됐는데, 만약 key_bit_queue가 비어있으면 타이머를 start하지 않는거지. 그러니까 이미 V 홀드 패턴이 매치됐다면
    key_bit_queue에는 아무것도 남아있지 않아. 그 상태에서는 타이머를 start하지 않게 하는거지. 그러니까 엔터키가 눌린상태에서
    그냥 패턴키 아닌 키를 입력해버리면 어차피 key_bit_queue에는 아무것도 들어가지 않음.
    이런 원리는 기존 pattern_matching에서도 똑같이 적용되는 원리다. 거기에서도 key_bit_queue가 비어있으면 그냥 중지해버림.
    그와 같은 원리다. 한번 테스트 해보자. 아주 잘 되는걸 볼 수 있다. 됐죠.

24-01-28_005
    그러면 이제 모든 패턴을 쫙 돌면서 테스트를 한번 해주자.
    일단 커맨드 모드도 테스트 할건데, 타이머에도 메세지 넣어주자. 잘되는지. 당연히 이건 잘 될거다.
    근데 커맨드 모드로 들어가는게 조금 껄끄럽네. 문제는 마우스나 키보드는 입력이 있어야 그제야 그걸 인식해서
    루프가 종료되는게 좀.. 웃기는데.. 이렇게 되면 안되지. 커맨드 모드가 들어가면 바로 종료되어야해. 타이머는 아예 시작도 안되서
    대기 상태에서 계속 기다리느라 break 하지도 못하고 있네.. 근데 진짜 이게 당연한게, 콜백 함수에서 이걸 체크하니까 당연히
    입력이 되어야만 커맨드 모드를 check하고 종료하는 거잖아. 그러면 PostThreadMessage(GetCurrentThreadId(), WM_QUIT, 0, 0);
    이 함수를 그때 부르는게 아니라 그냥 action function에서 바로 호출하면 될 것 같은데. 근데 마우스는 어케 정지시키냐.
    일단은 이걸 옮겨보자. 이거 어차피 현재 스레드 깨버리는거라 어쨌든간에 호출 측이 스레드면 그 스레드가 적용되는거라 내부의 내부
    함수에서 호출해도 상관 없음. 바로 스레드 뻗음. 아마도 키보드 후커는 제대로 됨. 마우스가 문제인데 마우스는 사실 움직이기만 하면
    종료되니까 상관은 없을텐데.. 그래도 제대로 해야지. 일단 제대로는 안되겠지만 테스트 해보자고. 아니 왜 안죽.. 아.. ㅋㅋ
    왠지 알겠다. 이게 따로 스레드 위에서 실행되잖아 . 그 스레드가 종료된거임..

24-01-28_006
    나중에 액션들 역시 SQL로부터 데이터를 끌어와서 그걸로 만들거다. 또, 액션같은거 키보드 입력을 통해 캡쳐하는 기능 만들어서
    그걸 SQL에 넣어버리고 그걸 재생할때에는 역시 그 SQL 데이터를 불러와서 그걸 기반으로 재생시킬 예정임. 이것도 꽤나
    험난 하겠구마이. 흠흠 슬슬 SQL도 만지게 되겠구만. ㅋㅋ 잼겠다. 근데 SQL은 어쨌거나 입력 출력 다 할 수 있어야해서
    GUI도 슬슬 만져야함. 그 과정에서 자연스럽게 SQL은 쓰는거고. 나중에 라이센스 문제 없도록 GUI는 오픈소스 기반으로
    상업 라이센스도 가져갈 수 있는거로 해야할것 같다. wx widget같은거 쓰면 될것 같은데.. 흠. 쉽진 않아보인다.
    GUI가 진짜 개잼있는 요소인데. 특히 이런 프로그램에서는 GUI를 이쁘게 멋지게, 기능적으로도 완벽하게 꾸미는게 가능하지.
    그건 진짜 프로그래머의 재능에 달린건데. 뭐 여러가지를 표시할 수 있지. 예를들어서 keyboard hooker나 mouse hooker의
    후킹 상태를 표시하는 기능이나. 뭐, 실행된 명령어를 찍어주는 콘솔 뷰도 하나 필요해 보이고. 설정창은 반드시 필요하고.
    뭐 단축키를 보여주는 기능. 그리고 어떤걸 누르면 키보드 레이아웃이 펼쳐저서.. 그건 힘들겠지만 만들면 좋겠지. 그걸 펼치면
    현재 사용중인 단축키도 보여주는거 가능이고. 블록키 누르면 블로킹 상태에서 쓸 수 있는 키 보여주고 등등. 이것도 재밌겠네.
    근데 이런거 전부 만드려면 진짜 개 오래 걸릴것 같다 진짜 ㅋㅋ 일단 키보드 레이아웃을 그대로 만드는것 부터가 장난이 아닐듯.
    엄청난 노가다일 수 있는데, 이걸 미리 구현해놓은건 없을까 ㅋㅋ 그리고 재생기능. 예를들어서 단축키 목록에서 재생 누르면
    키보드 레이아웃 뜨면서 어떻게 눌려야 그게 실행되는지 천천히 알려주는거지. 근데 그건 좀 어려울듯 .. ㅋㅋ

24-01-28_007
    말이 커맨드 모드지 사실은 그냥 스레드 루프 종료 시키는 기능임. 사실상 GUI 만든다고 확정했으면 커맨드 모드는 거의 필요하지 않다.
    단순히 프로그램을 테스트하고 조작하기 위한 기능일 뿐이지. 이제 GUI로 넘어가면 변수 하나 만들어서 GUI에서는 콘솔 출력을
    전부 막아버리는 변수도 하나 필요해보인다. 일단은 그래도 스레드 루프 종료하는걸 다시 제대로 만들어봐야지.

24-01-28_008
    일단은 대충 급하게 스레드 종료하는 코드를 만들어놓았다.

24-01-29_000
    Actions 열거형도 좋긴한데.. 만약 없으면 액션 아이디 가지고 판별하게 하려고 한다. 그렇게 해야 후일에도 커스텀 액션
    만들때도 편하고. 그러니까 특정 액션만 따로 구현해서 필요한 function 가져다가 쓰는거고. 그러니까 열거형 대신에 SQL의
    primary key 이걸로 조지자는거지. 그러니까 이게 액션도 여러가지 종류가 있어. 내 생각에는 그냥 따로 Action이라는 클래스를
    만들어서 Action에 대해서 정의하는게 좋아보임. 액션에도 타입이 있어. 그냥 순수하게 매크로만 실행하거나 아니면 command mode,
    exit program같은 특수한 액션도 있고, 뭐 토글 키에따라 켰다 끌 수 있는 액션 같은거도 있고 등등. 아무튼 이것도 패턴 처럼
    비슷하게 만들긴 하는데 패턴이랑은 다르지. 그러니까 그 대략적인 형태는 비슷하지. 근데 패턴하고 다른점은 얘는 실행하는 함수가
    있고, action id를 가진다 이거야. 그리고 이에대한 SQL도 얼른 만들어서 구현해야할 것으로 보인다. 아 또 대수술 감행해야함.
    아무튼 Acion 이거 클래스로 만들어야함. 근데 어차피 이거 말인데. 클래스로 만드는건 좋은데, 이걸 key_pattern 클래스랑 어떤
    관계이냐. has_a 관계잖아. 어? 안그러냐고. 그러니까 근데 이게 상속관계는 전혀 아니라는 거임. 확실히 상속 관계는 절대
    아니지. 그냥 key_pattern 객체가 가지고 있는 항목이지. 아무튼 SQL 테스트 하고 action도 만들고. 내 생각에는 key_pattern
    id도 새 변수로 추가해야한다. 그래야 SQL에서 관리가 가능함. 오키도키. 알긋나! 그냥 이렇게 하면 key_pattern을 나중에
    confirm 하고 그걸 넘기잖아. 그때 실행해야할 aciton 객체를 key_pattern이 가지고 있으니까.
    근데 만약 토글키처럼 action이 두 개 이상일 수도 있을 수도 있지 않느냐 이거야. 아니면 예를들어서 다른 명령에 의존적인 명령은
    서로 다른 action을 수행할 수도 있다 이거야. 그렇잖아. 예를 들어서 CEO때 실행하는 명령이랑 그냥일때 명령이랑 의존적으로
    다른 action을 취할 수 있다는걸 알아야함. 그래서 내 생각에는 key_pattern이 action 객체 여러개를 가질 수 있도록 하는것도
    생각을 해 봐야한다는 것이지. 근데 key_pattern이 액션을 가지는게 맞을까. 흠흠흠. 일단 토글에 대한 것도..
    근데 토글 패턴 말인데. 토글 패턴을 저장하는 벡터 말이야. 이것도 뭔가 참조로 받는게 낫지 않을까 싶은데. 왜냐면
    토글 키 bool은 원본 key_patterns에서 관리해야하잖아. 맞잖아. 그러니까 참조로 받아서 원본을 수정하는게 맞지.
    그럼 참조를 담는 벡터를 만들어야함.

24-01-29_001
    command mode로 진입하기 전에 미리 keyboard와 mouse의 스레드 id를 받아놨다가 한꺼번에 종료시키게 만들었다.

24-01-29_002
    아니 뭐.. 근데 action을 따로 객체로 만든다고 해도. 흠.. 근데 만약 SQL에서 불러온다면 command mode 같은 특수한 함수를
    받을 수 있도록 해야하는데.. 그러니까 SQL에서 구분자는 pid 말고는 없음. 이걸 이용해서 매칭하던지 해야함. 예를 들어서
    action에서 pid를 unsigned로 지정해서 그걸 가지고 function_map을 만들어서 pid에 따른 function을 따로 만들어서 매칭
    시키던지. 그러니까 특별한 함수에는 그렇게 해야함. 이걸 구분하기 위해서 특별한 함수가 쓰인다는 bool도 필요해보이고.
    그게 아니라면 이 action은 단순히 매크로 키를 타이핑하는거다 하면 이것은 정보를 또 SQL에서 불러오도록 하면 됨. 그러니까
    패턴키에 의해 실행되는 action이 프로그램 의존적인 함수는 따로 special_function_map으로 하고 key를 action pid로
    지정하면 된다는거임. 그 외의 단순 매크로 함수는 각 키를 입력하는 함수같은거를 만들어서 단순 입력하는건데 그 재생 정보를
    역시 SQL에 기반한 lookup table에서 가져오는거임. 당연하지만 SQL에서는 단순히 현재 저장된 데이터를 뽑아서 데이터를
    프로그램의 메모리에 불러오는 역할임. 그 외에는 프로그램에서 수정할거 있으면 수정하고 삭제하거나 업데이트 하는 역할을
    담당하고. SQL에서 직접 불러와서 재생하는 짓은 하면 안됨. 그렇게 하면 프로그램이 매우매우 저 성능으로 효율성이 매우 떨어짐.
    왜냐면 SQLite 특성상 디스크에서 불러오는거라 속도가 매우매우 느림. 반드시 초기화 할때 SQL에서 미리 데이터를 불러와서
    메모리에 할당하는게 올바르다. 그리고 keyboard data같은거 동적 메모리에 할당하려면 어떻게 해야하는지도 알아봐야함. 뭐
    구지 동적 메모리에 할당할 필요는 없어보이긴 하지만 key_bit_queue같은건 흠. .

24-01-29_003
    근데 생각해보면 queue나 vector같은 애들은 구지 이거 쓰는 클래스까지 동적 메모리 할당할 필요는 없음 전~혀 필요가 없어.
    왜냐면 어차피 얘네들은 알아서 동적 메모리에 할당되고 자동으로 관리되기 때문임. 근데 솔직히 동적 메모리도 소찌끼 그냥
    대부분은 배열같은 컨테이너 만들때 쓰는건데 이미 표준 라이브러리에 컨테이너나 알고리즘은 아주아주 잘 만들어짐. 내가 구지
    그걸 만들어 쓸일은 거의 없다 이거야. 안그러냐고

24-01-30_000
    SQL을 시연해보고 있는중. 정말로 흥미로운 프로그램이다. 나중에 나도 archive를 쓸날이 올까. archive는 말 그대로
    아카이브다. 여러 데이터베이스들을 저장할 수 있다. 이것은 파일 컨테이너로써, 단순히 파일을 저장하고 업데이트하고 추출하는 등의
    컨테이너, 즉, zip과 같은 기능을 제공한다. 따라서 이 안에 있는 database를 쓰려면 파일을 추출해야한다는것. 즉, 그냥
    데이터 베이스 같은 데이터들의 묶음이라고 생각하면 된다.

24-01-30_001
    계속 SQL을 테스트하고 CLI 프로그램도 계속 써보며 익숙해지게 연습하고 있었다. 아. 역시 SQLite3는 진짜 C++만큼이나 재밌는
    녀석이다. 그리고 메모리 데이터 베이스라는 개념을 써보기로 하였다. 이것은 임시적으로 메모리에서 할당된 데이터베이스인데.
    이걸 이용하면 여러가지 데이터 베이스 동작을 아주 효율적이고 빠르게 처리할 수 있을 것으로 기대된다. 다만 주의할 점은
    데이터의 변경이 일어날 경우 중간에 익셉션이 나거나 해버리면 원본 디스크 db에 저장을 못할 가능성이 있기 때문에 그런 점을
    항상 주의해서 코드를 짜야한다는 것. 흠흠흠.

24-01-30_003
    wxWidget 라이브러리를 설치하고 있다. windows precompiled binary를 받아서 설치하고 있다.

24-01-30_004
    서브컴에도 wxWidget을 설치해줬다. 그리고 cmake를 서브컴과 메인컴을 상위 디렉터리에서 com.txt를 읽어서 그 값에 따라
    자동으로 현재 컴에 cmake list를 설정해주게 만들었다. 일단은 오늘은 늦었으니 내일부터 다시 wxWidget을 이용해서
    GUI를 만들어보자. 그리고 GUI를 만들면서 SQL을 이용해서 데이터를 불러오는 것도 해보자.

24-01-31_001
    슬슬 wxWidgets을 가지고 이것저것 테스트해보며 코드를 하나씩 짜올릴 생각이다. 그나저나 아두이노는 왜 갑자기 또 컴파일 에러뜨냐?
    설마 컴파일러 바뀌었나. 그건 아닌데. 흠.

24-01-31_002
    역시나 gui, 특히 wxWidgets을 도입하는건 여러가지 어려움이 따른다. 일단 cmake에서부터가 안먹히는게 많아서 삽질 좀 했다.
    일단 main 함수를 없애줬다. 이게 문제가 뭐냐면, 만약 WIN32를 쓰면 이때에는 어플리케이션이 Windows 서브시스템으로 되기 때문에
    이 때에는 wxIMPLEMENT_APP 매크로를 써야 WinMain()이 만들어진다. 그리고 cmake에서 WIN32를 쓰느냐 안 쓰느냐를 나는
    USE_CONSOLE 이라는 option을 지정해서 구현했다. option(USE_CONSOLE "use console" OFF) 이런식으로 말이다.
    그리고 이 옵션에 따라

    if(USE_CONSOLE)
        add_definitions(-DUSE_CONSOLE)
        add_executable(gta_c2 ${SOURCES})
    else()
        add_executable(gta_c2 WIN32 ${SOURCES})
    endif()
    이런식으로 지정해주었다. 만약 콘솔을 쓰게 되면 이 옵션은 ON이 되어서 빌드되며, 매크로에는 USE_CONSOLE이 정의되어서
    main.cpp에서

    #ifdef USE_CONSOLE
    wxIMPLEMENT_APP_CONSOLE(main_window::MainApp);
    #else
    wxIMPLEMENT_APP(main_window::MainApp);
    #endif
    이런식으로 옵션이 ON일 때에는 main()을 생성하도록 wxIMPLEMENT_APP_CONSOLE을 사용하고, OFF라면 WinMain()을 생성하도록
    wxIMPLEMENT_APP을 사용하도록 하였다.

    그리고 이러한 옵션을 통해 빌드하기 위해서 windows 시스템에서는 cmake-gui 프로그램이 필요했다. 이 프로그램 사용법은 간단한데,
    우선 source code directory를 프로젝트 루트 디렉터리로 지정해주고, build the binaries를 빌드 디렉토리로 지정해준 다음에
    옵션을 체크하거나 해제한 뒤 Generate를 누르면 cmake 파일들이 옵션에 따라 만들어진다. 그 다음에 여기 clion에 다시 와서
    내 컴파일러로 빌드하면 옵션대로 빌드된다. 아까 테스트 해봤는데 콘솔 프로그램, windows 서브시스템 프로그램 둘 다 잘 작동하는걸
    확인했다. 어차피 릴리즈 단계에서는 콘솔 옵션을 쓸 이유가 없기 때문에 이렇게 콘솔을 사용하냐 마냐를 옵션으로 만들어버린것.

24-01-31_003
    이제 슬슬 wxWidget을 가지고 뭔가를 하나씩 만들어야한다. 그 전에 설계를 더 해야하는건 당연하다.
    그리고 이제 초기화를 해주는 부분에 있어서는 MainApp 클래스의 OnInit() 메서드를 통해 해야한다는것이다. 여기에 초기화할 것들을
    넣어주면 된다는것. 이제 키보드 마우스 후커와 패턴 코드들이 서로 잘 실행되는지도 테스트를 해봐야할 것이다.

24-01-31_004
    근데 문제는 이렇게 해버리면 commander에서 join 때문에 블로킹 상태에 빠진다. 이걸 detach해야하는 것으로 바꿔야할듯.
    근데 그럼 커맨더는 어케 쓰냐 ㅋㅋ 아니면 그냥 커맨드 모드 들어갈때 커맨더를 다시 호출하던가 흠. 일단은
    detach를 해야함. 그래야 gui 루핑을 돌릴 수 있으니. 근데 사실상 커맨더는 좀 불필요하긴 하지. ㅋㅋ
    아니 쉬바 솔직히 커맨더로 뭘 할건데. ㅋㅋ 만약 스레드 다 깨버리고 커맨더로 돌아왔다 쳐도 다시 다 시작해야하는데.
    문제는 그런식으로 컨트롤해버리면 wxIMPLEMENT_APP_CONSOLE을 쓸 수가 없지. 다시 main()을 만드는건 duplicate main
    되버리잖음. 근데 솔직히 이제 commander로 뭘 하고 그건 좀.. 근데 나중에 이미지 캡쳐하고 그거 하려면 필요하긴 함.
    캡쳐모드 이런거 켤때는 필요할지도 모르지. 그리고 더 중요한건 SQL 다룰때에도 필요할 수 있고. 그러니까
    wxIMPLEMENT_APP_CONSOLE 이거를 쓰면 좀 문제가 생긴다는 거임.

24-01-31_005
    CLI11을 통해 command line interface를 아주 멋들어지게 만들까 생각중이다. cli로 할 수 있는건 모든지 다 된다.
    안되는건 없다. 이걸로 차분히 cli를 매력있게 구현해버리자.

24-01-31_006
    Windows SDK랑 #include "wx/wxprec.h"랑 서로 충돌해버리는 문제가 생겼었다.
    wx/wxprec.h가 winsock2.h를 포함하고 있는데 그 전에 windows.h를 써버리면 충돌이 일어난다.
    따라서 다음과 같이

    #include "view/main_window.h" << winsock2.h를 포함하고 있음
    #include "action_operator.h"
    #include "actions.h"
    #include "commander.h"
    #include "key_patterns.h" << windows.h를 포함하고 있음
    #include "timer.h"

    winsock2.h를 포함하는 애를 먼저 선언해주어야한다. 그 뒤에 windows.h가 와야한다. 이렇게 하니 다시 빌드가 정상적으로 됐다.

24-01-31_007
    이제 CLI11으로 CLI를 만들고 키보드와 마우스 스레드도 detach하고 본격적으로 CLI를 만들어보자.

24-01-31_008
    지금 이렇게 하면 테스트 조차 버거움. 하나씩 해야함 무조건.
    결국에는 https://www.appsloveworld.com/cplus/100/293/unable-to-catch-sigint-sent-by-clion에 나온 방법대로
    레지스트리를 수정해버렸는데 문제는 이렇게 하면 stop 버튼을 누르면 비정상 종료 코드인 -1로 종료되어버려서 이것 역시
    signal로 처리할 수가 없다는 것이다.

24-01-31_009
    뭔가 문제가 많다. gui를 X로 종료할때 abort가 생기는데 이 문제점을 고쳐야한다..

24-01-31_010
    커맨드 모드로 들어갈때 타이머를 start해서 confirm을 한번 더 호출한 문제를 command mode 진입 변수로 해결했다.

24-01-31_011
    CLI app에서 자꾸 블로킹되는 현상이 생긴다. 아무래도 테스트를 따로 해야할것으로 보인다. 공식 문서를 참고해서 해봐야겠다.
    아마도 스레드 때문에 그런것 같다. 메인에서 하면 잘 된다.

24-01-31_012
    CLI를 계속 테스트하고 있다. 그리고 GUI X버튼을 누를때 commander에서 command loop 때문에 정상적으로 종료되지 않는
    현상을 수정해야할 것이다. 아마도 wait 때문일것. 언젠가 정말 멋진 CLI 프로그램을 완성해줄테다.

24-02-01_001
    Exit 패턴을 입력하고 명령을 실행할때 자꾸 여기 main_window::MainApp::GetInstance()->ExitMainLoop();에서
    abort() 에러가 뜬다. gui도 제대로 종료되지 않는 현상이 있다. ExitMainLoop()가 OnExit를 호출하고 OnExit에서는
    frame->Close(true);를 통해 OnClose를 호출하는데 이미 Exit action에서
    action_operator::break_key_pattern_threads();를 호출했었는데 OnClose에서도
    action_operator::break_key_pattern_threads();를 호출해서 이 함수 안에 있는 뮤텍스 락이 서로
    데드락 상태에 빠져서 생긴 오류였던 것. 그래서 Exit action에 있는
    action_operator::break_key_pattern_threads();을 빼주었다. 어차피 Exit action을 실행하면
    OnClose에 도달하기 때문에 전혀 그것도 필요 없고. commander::exit_program.store(true);도 OnClose에서만
    처리하게 바꾸어주었다. 이걸 통해 해결.

24-02-01_002
    command line interface 객체를 commander가 아닌 main_window::MainApp에서 만들어주었다. 뭔 근데
    인스턴스 정도는 commander.h에 올려도 상관은 없어보이는데 근데 그렇게 해버리니 뭔가 문제가 계속 생겼다. 왜 그런지는
    자세히는 모르겠는데 아마도 commander, 특히 commander future위에서 CLI::App 객체를 올리면 블로킹 되는
    이상한 현상이 있었다. 그래서 이제는 대체된 main이 있는곳인 OnInit()에서 CLI::App 객체를 초기화해주고 있는데..
    근데 문제는 예를들어서 USE_CONSOLE 옵션이 OFF인 경우에도 이게 제대로 작동할리가 없다는것인데.. 한번 테스트 해보긴
    해봐야할것이다. 다행히 지금은 잘 된다. 아무래도 이게 Windows 서브시스템 즉, WinMain()이 되버리면 어차피 콘솔은
    싹다 무시되니 말이다. 아무튼 릴리즈때에는 콘솔에 출력되는게 하나도 없도록 해야하는것은 당연하다. 릴리즈 버전과 디버그
    버전은 엄연히 다른것이다. 콘솔 출력부를 남기는것도 성능에 어느정도는 영향을.. 미치진 않겠지만 그래도

24-02-01_003
    흠. 근데 솔직히 이 프로그램만으로 모든걸 할 수 있게도 하겠지만 그게 맞는건지는 모르겠다. 근데 어차피 이걸 써야하는 이유가
    예를들어서 SQL을 관리하고 데이터를 집어넣고 업데이트하고 삭제하고 하려고 해도 어쨌든 키 입력에 기반하는거라 어쨌거나 이
    프로그램을 통해서 쓰면 그게 다 되니까. 어차피 릴리즈때에는 그런 기능들은 넣지 않고 릴리즈 버전은 따로 만들어서 배포할거라
    그닥 상관은 없겠지. 그나저나 역시 다른 User들이 쓰는걸 생각하고 배포할것 까지 생각해보니까 진짜 프로그램 좀 진짜 거의
    완벽하게 작동하도록 설계하는데에 너 무게가 실리는게 느껴지긴 하네. 물론 나는 디자인 패턴, 아키텍쳐 이런거 아무것도 모르긴
    한데, 그래도 저번 파이썬 매크로보다는 훠어어얼씬 잘 만들어진 프로그램이라는건 확실함. 이렇게 언어의 각종 패러다임, 객체 지향,
    함수형, 단일 책임 원칙, 한 함수에는 하나의 기능, 재사용, 추상화, 싱글턴, 스레드, 뮤텍스 동기화 매커니즘, 아토믹 연산,
    락 가드, 퓨쳐와 어싱크 비동기 프로그래밍, 이벤트 루프, 키보드 마우스 후커, SendInput, windows api, GUI 라이브러리,
    SQLite3, BitBlt, 이미지 프로세싱 등등 수많은 요소들이 들어가 있다. 현재까지는 괜찮다. 게다가 특히 키보드 후커 만큼은
    여타 다른 매크로 프로그램이나 키보드 입력 매커니즘 만큼은 내 프로그램만한 프로그램이 거의 전세계에 없을지도 모름. 이런 복잡한
    입력을 지원하는 키보드 입력 매커니즘 알고리즘은 진짜 내 프로그램이 거의 유일한 솔루션이 되버림. 실제로도 이걸 구현하는데만 거의
    2~3주가 걸릴 정도로 굉장히 고단한 작업이었고, 디버그 하는것도 힘들었지만 결국 끝내d 만들어버렸고. 아직 Edge Test는 제대로
    된건 아니지만 그래도 거의 완성 단계에 다다르게 됐음. 이건 정말로 자랑할만한 사항은 된다고 본다. 내가 의도한 대로 키 입력
    처리 매커니즘이 아주 잘 작동하니까 말이다. 키 필터링, bitset을 이용한 ket_state, key_bit_queue, 타이머를 이용해서
    key_bit_queue를 입력하는 매커니즘, 릴리즈 타이머, 프레스 타이머, 특히 프레스 타이머를 이용한 단일 홀드키 바인딩 추적,
    다중 홀드키 구현, 토글키 구현, 노멀키 구현, 시퀀스 키 구현, 그리고 큐를 이용해서 패턴 매칭이 될 때마다 큐 pop되면서
    다음 패턴으로 자연스럽게 넘어가는 메모리 poping 알고리즘 이라던가 그리고 3중으로 이루어진 패턴 매니저. 패턴, 그리고 combine
    key 객체 까지. 꽤나 괜찮은 객체 디자인이었고. 이제 필요한건 aciton 객체, 그리고 SQL을 통해서 입출력을 해서
    패턴을 구현하는것 까지 하면 꽤나 진행된 것이고. 그리고 역시 모든 동작이 C++을 통해서 이루어지다 보니 구현해야할게 정말
    많았고. 이것이 실제로 프로그래밍 언어가 동작하는 원리 그 자체이고 물론 날것의 C 정도는 아니지만 그래도 그거에 가까운 언어라서
    구현하는게 쉽진 않았지만 그래도 성과도 있었고 재미도 있었고. 특히 Copilot의 역할이 진짜 나보다 컷음. 코드의 거의 대부분이
    코파일럿을 통해서 만들어진 코드이고. 물론 내가 아주 세밀하게 수정한 코드들도 많았지. 즉 진짜로 말 그대로 Copilot 그 자체였다.
    말 그대로 Copilot과 나는 하나의 비행기를 조종한 셈이었고 나는 그의 제안에 따라 여러 코드를 만들고 세심하게 수정하고
    디버그하고 그랬지. 정말 그동안 게임하는것 만큼이나 정말 재밌었던 코딩, 설계. 정말 나는 이 시대에 태어나서 행복하다.

24-02-01_004
    vcpkg toolchain 경로 변경해줌. 일단 메인컴에서도 cmake가 의도대로 잘 작동하는것 같아 좋다.

24-02-03_001
    흠흠. cli app을 commander.h로 옮겼다. 어차피 초기화는 메인에서 해주니까 상관 없을거다.

24-02-03_002
    이제 본격적으로 대충으로라도 앱 다시 설계하기 시작해야한다. 기본적으로 무엇을 해줄까. 흠흠흠 고민해보자.

24-02-03_003
    뮤텍스가 해제되지 않았는데 프로그램이 종료되서
    D:\a_work\1\s\src\vctools\crt\github\stl\src\mutex.cpp(49): mutex destroyed while busy
    가 호출된것 같은데.. 한번 체크를 해봐야겠다. 내 생각에는 넷 중 하나이다. 둘 이상일 수도 있고.
    키보드 후커, 마우스 후커. 근데 얘네들은 구지? 일단 따로따로 떼어나서 뭐가 문제인지 봐야겠다.
    key_press_timer가 Program exit보다 나중에 종료되는게 문제다. 이걸 어떻게 해결해야할까.. 왜 그럴까.
    분명 key_release_timer는 제대로 종료되는데. 근데 key_press_timer는 왜 안되는걸까. 일단 동작 매커니즘을 하나하나
    뜯어보며 디버그를 제대로 해야할것 같다. 출력문도 새로 만들어서 말이다. timer를 중심으로 출력문을 만들어야겠다.
    일단 timer에서 timer가 계속 돌아가는지를 체크해야할 것 같고. timer sleep을 좀더 길게 가져가보자.

24-02-03_004
    key_press_timer가 늦게 종료되는 현상을 계속 추적중이다. 문제는 key_press_timer가 이상한 곳에서 대기가 걸려서
    into_command 변수를 읽지 못해서 exit(0) 이후에 종료되는것 같다.
    그러니까 문제는 이게 F1+F4도 패턴키라서 눌렀을때 push_to_key_bit_queue가 호출될때 key_press_timer가 시작된다는것.
    그래서 이때에는 1, 2 과정까지는 진행되는데 문제는 그 과정 중간에 다른 애들이 break 되고. 특히 가장 큰 문제는 그 중간에
    Program exit(0)가 걸리면 그때 이 문제가 터진다는거임. 그러니까 반드시 exit(0) 전에 key_press_timer가 정상적으로
    종료가 됐는지를 확인하는 코드가 필요하다는거임. 그러니까 key_press_timer가 패턴키가 눌림에 의해 시작되는 현상을
    막을 수는 없음. 그렇게 하면 내가 의도한 바가 아예 안되니까 그건 안됨. 다만 그 루프가 돌고 있는데 exit(0)가 호출되면
    그때 이런 문제가 생긴다는거. 그러면 근데 join을 써야하는데. 어차피 detach를 썼네.. 흠. 근데 여기서 detach 해버리면
    나중에 join을 할 수가 없잖아.

24-02-03_005
    결국 join을 이용해서 해결했다. thread가 종료되기 전까지 기다려주니까 모든게 깔끔하게 해결됐다. 이렇게 하면 아마도
    왠만해서는 이런 버그가 생길 수 없는게, 종료까지 기다린 다음에 exit(0)를 호출하니까 이제 잘 될거다. 이제 gui를 올려서
    종료 테스트를 다시 해보자. 디버그는 지워도 될것 같다.

24-02-03_006
    문제는 frame_of_action이 중간에 종료되어 버리면 끝까지 실행이 안되는 현상이 있을 수도 있다는 것이다. 그것 때문에
    abort()같은게 또 뜰 수도 있다는 것. 그러니까 처음에 frame_of_action에서 function을 실행했는데 그 exit function에서
    프로그램이 종료되어버리면 그 이후 문장이 unreachable이 되어버린다. 그러니까 execute_key_pattern_opt을 검사해서
    이것이 reset되기까지는 대기를 하는 코드를 작성해야 한다는것이다. 그 다음에 event.skip()을 해서 종료시키면 될것 같다.
    근데 이럴 필요가 없는게, 어차피 OnClose를 다른 스레드에서 실행시키는게 아니라 호출에 의해 알아서 기다리니까 코드는 정상적으로
    된다는것. 게다가 event.skip()이 프로그램을 종료하는 코드가 아니라는것이다. 따라서 그 이후 코드도 알아서 실행되는 것.
    뭐 제일 좋은 방법은 그냥 테스트를 계속 해보는것이다.

24-02-03_007
    단일 홀드키가 key_patterns에 그냥 포함되버려서 단일 홀드키가 만약 V인데 V_X라던가 normal V가 포함될때는 상관 없는데 그냥
    단일 홀드키만 있는 경우에 그냥 V를 눌러버리면 이게 key_patterns에 있어서 confirm을 할 때 하나의 패턴이 정해진걸로 되기
    때문에 V키를 그냥 눌렀음에도 불구하고 V hold key 패턴을 실행해버리는 현상이 있었다. 결국 처음 초기화때 모든 key_patterns를
    넣을때 단일 홀드키에 대해서는 pass하게 해주니까 다시 제대로 작동하는걸 확인했다. 그러니까 단일 홀드키랑 그 외의 키는 반드시
    무조건 분리를 해주는게 맞다는 것이다. 타이머도 분리해야하고 pattern vector도 확실하게 분리하고 필터도 분리해야한다.
    그럼 이렇게 하면 confirm에서 2 이상의 current를 확인할때에 싱글 홀드키에 대해서 continue 하는 부분을 없애도 될 것 같다.

24-02-03_008
    엔터키만 눌렸을때 리소스 초기화가 제대로 되지 않아서 다시 수정해줬다.

24-02-03_009
    이제 SQL을 이용해서 패턴을 넣는걸 해야할것 같다. 그리고 action 객체도 만들어서 key_pattern에 포함시켜야하고. SQL 테이블도
    어떻게 구성할건지 짜야할듯. 아마도 GUI보다는 이게 우선일 것 같다.

24-02-04_000
    action 객체 만들라고. 그리고 아까 생각한건데, 액션 객체가 실행할 함수를 여러개 만들어놓고 그걸 아이디 같은걸 따서 각각 실행할
    수 있게 만드는거임. 그 다음에는 SQL에서는 그 아이디를 이용해서 실행 목록을 만드는거야. 그래서 일단은 함수랑 그걸 담을
    function_map이 필요함. 그 다음에 그걸 이용해서 SQL에서 불러와서 key_pattern 객체 만들때 그 안에 넣을 action도 같이
    담는거지. 유기적인 연결이 필요하기 때문에 외래키 방식이 필요할거고 당연히. key_pattern에 속하는 action의 재생 목록을
    불러오는거야. 그러니까 SQL에는 이제 어떤 테이블들이 들어갈지도 짜야하고. 일단은 action 객체를 만들고 action에 대한것,
    key_pattern에 대한것들을 만들어야지. 그걸 입력하는것도 만들어야하고. 함수도 만들어야하고. 할게 많다.

24-02-04_001
    일단 key_pattern좀 수정하자. 아마도 대 수술이다 이건. ㄹㅇ 그리고 일단 임시로 SQL 다루는 명령어 CLI app을 만들어야할듯?
    일단 객체 클래스 만들고 SQL table 구성 어떻게 할건지도 정해봐야지. 중요한건 action function map이랑 그걸 재생할
    재생 목록 정도이고. SQL에 어떻게 그걸 저장할거고 어떻게 불러와서 내부 table은 어떻게 구현할건지 등등 정해야함.
    Combine key를 어떻게 저장할거냐. 일단은 우리가 쓸 수 있는건 key code map을 이미 만들어놨으니까 그걸 쓰는게 맞음.
    아무튼 핵심은 키후커 입력을 받아서 키보드 시퀀스를 받아서 그걸 SQL에 저장하고 불러오는 기능을 만들어야함. 근데 이게 진짜
    만만치는 않을건데 일단은 이런 방향이다 이거야. 아 그리고 그 전에 일단 기존 데이터에서 이게 유효한지 검사하는 유효성 검사
    코드도 당연히 만들어야함. 진짜 생각보다 쥰내 복잡하다. 게다가 이제 SendInput으로 이제 매크로 실행하는것도 만들어야하는데
    우선은 테스트코드로 scan code랑 extension key 따는것도 만들어야함.
    내 생각에는 Actions 열거 변수는 그냥 없애는게 나을듯 함. TEST도 그냥 싹 날리고 SQL로 다시 다 만들어야함. ㄹㅇ
    내 생각에는 우선 키패턴 만드는 자동화 코드 먼저 만드는게 좋을 것 같다. 근데 그걸 하려면 key_pattern 클래스랑
    action 클래스가 정의되어야함.

24-02-04_002
    Action 클래스를 만들어야함. 기본적으로 action_id랑 action_name, action_function 순서를 담는 vector 같은거
    필요할듯. 가장 중요한건 액션 함수들을 실행하는 vector인데. 이걸 vector로 만들어야하는지 흠. 어쨌든간에 목표는
    여러가지 기본 action 함수들을 순차적으로 실행하는건데. 이런 함수들을 미리 만들 필요가 있고. 예를들어서 뭐 화살표 키 라던가
    엔터키, M키 이런게 다 필요함. 이런 함수들을 담는 function_map이 필요하고. 흠. 글쎄. 이 함수들을 관리하는 SQL가 필요할지.
    좀 생각을 해봐야함. 그러니까 action객체의 핵심은 이런 기능 함수들의 순서를 담는 배열이 핵심임. 이걸 그대로 실행해주는 기능도
    당연히 필요하고. 그리고 그걸 실행하는 스레드는 기존 ActionOperator 의 operate 메소드에서 frame_of_action을 통해
    실행할 것임. 이제 confirm에서는 key_pattern에 담긴 action 객체를 이용해서 이걸 수행하게 할 것이고.

24-02-04_003
    그래서 action 클래스를 어떻게 만들건가 이제 해야함. 일단은 action id. 근데 action_name은 구지 필요함? 왜냐면
    어차피 이 객체는 key_pattern 객체에 속할건데? 구지 필요하냐고. 근데 나중에 식별하려면 필요할듯. key_pattern에서
    가져오면 되지. 근데 이렇게 할거면 그냥 믹스인 클래스를 구현하는게 낫지 않나 싶기도 해. 어차피 key_pattern이랑
    action이랑 이건 has-a나 is-a가 아닌, 믹스인. 즉, 서로 섞여야하는 클래스라서 말이지.
    아니면 지금이라도 클래스에 관련된 부분은 책을 읽어보는것도 나쁘지 않을것 같음. 클래스 개념을 명확히 파악해야 이런애들을
    전부 구현하는데 조금이라도 더 세심한 포인트를 짚어야하기 때문. 다소 시간이 걸리더라도 말이다.

24-02-05_000
    Action 말인데. 이게 신중해야하는게. Action도 조건에 따라 여러가지 다른 액션을 수행할 수 있도록 해야한다는 거임. 예를
    들어서 CEO인 상태에서 모싸 오토바이를 소환한다거나, 모싸인 상태에서 모싸를 풀고 CEO의 방탄복이나 불샤크 혹은 버자드를
    소환 하는 경우임. 이런 상태 조건 변수도 필요하거니와. 일단은 GTA에서 상태에 따라 달라지는 변수는 CEO나 모싸가 있지만
    그외에도 다른 변수가 있을 수 있음. 그러면 action 객체를 어떻게 정의할 것인가.. 이걸 key_pattern에 포함시켜야할지
    아니면 그냥 독립적인 action 객체를 다른 컨테이너에 담아서 여서 변수 조건에 따라서 그걸 call해야할지.. 뭐 그런게 좀
    애매 하다 이거야. 그러니까 예를들어서 노멀인 상태에서 버자드를 소환하는거랑 CEO인 상태에서 버자드를 소환하는거랑, 모싸인
    상태에서 버자드를 소환하는거랑은 서로 다른 액션이 좀 필요하다 이거야. 물론 액션의 구체적인 실행은 또 다시 수많은 function들의
    반복 혹은 나열식의 호출로 구성되지. 아마도 이것은 function_map을 순차적으로 SQL에 의해 불려진 데이터에 의해 재생하면
    된다는 것이지. 근데 이럴거면 구지 action 객체가 정말로 필요하냐는거야. 어차피 action이라는 것은 일단 가장 중요한건
    재생 목록이고, 그 다음에는 그 재생 목록 안에 있는 단일 함수인데. 내 생각에는 차라리 GTA에 있는 각종 상태 변수에 대한걸
    구조체 같은걸로 정의해 놓는게 좋다는 거지. 이것은 플래그 형식으로 bool 형식의 스택 데이터 구조체를 이용해서 만들 수 있을
    것 같다. 동적 할당할 필요까지는 없는데 만약 그런게 생기면 컨테이너로 넣으면 되고. 어차피 플래그만을 저장하기 때문에 뭐
    객체로도 만들 수 있겠지만 데이터만 가지면 구조체로 구현하는게 더 좋을 수 있다. 직관적이고. 구조체는 클래스랑 거의 똑같은데
    접근 제어자 정도가 좀 다른거고. 여기에도 메서드를 정의할 수는 있다. 이런걸 내 생각에는 어차피 action_operator 측에서
    사용해야하니까 여기 헤더에 정의해도 될 것이다. 구조체 사용에 대한 부분은 좀 다시 읽어볼 필요는 있겠다. 그리고 구조체에서도
    클래스와 마찬가지로 접근제어자를 지정하는게 가능한데, 기본적으로 public으로 default가 되어있다. 근데 구조체는 어차피
    값에 직접 접근해서 뭔가를 컨트롤하는게 목적이라 그냥 public으로 멤버 변수를 가지도록 하는게 나아보인다.

24-02-05_001
    아무튼 action 객체라는게.. 좀 정말로 애매하다. 물론 이러한 단일 함수들의 재생 목록을 담는 객체는 확실히 필요해 보인다.
    그리고 이런 객체를 SQL로부터 불러오거나 수정하는 기능도 필요해보인다. 그리고 action의 객체가 필요한 이유는 여러가지 플래그에
    의한 서로 다른 동작을 구현하기 위해서라도 이런것이 필요해보인다. 이것을 코드 중복을 피하고 재사용성을 높이면서 추상화가 가능하게
    설계하고 하려면.. 여러가지 방법을 구현해야한다. 특히 플래그에 따라 달라지는 행동이 있을것이고 특히 가장 중요한건 무엇보다도
    실제 설계 목표인 상호작용 메뉴의 어떤 특정한 상황을 각각 분리해서 다루어야한다는 것이다. 그래야만 코드 중복을 피할 수 있을 것이다.
    물론 각 메뉴를 이동하는 키들에 대한 SendInput에 대한 부분을 분리해서 설계해야하는건 맞다. 이들은 단일 함수로, 한 키 입력의
    역할을 맡게 될 것이다. 그리고 그보다 상위 계층에서는 각 상호작용 메뉴의 각 부분에 대해서 컨트롤 할 수 있도록 함수 실행 부분을
    각 단계로 나누어 분리해야한다는 것이다. 이렇게 분리된 상황에서 각 메뉴를 이동할때 숫자만 가지고 특정 메뉴끼리 이동할 수 있도록
    코드를 짜야 재사용을 최대한 활용할 수 있을것이다. 내 생각에는 아예 메뉴에 대한 모든 목록을 미리 뽑아 놓는게 낫지 않을까 싶다.
    어차피 메뉴라는건 첫 메뉴만 달라지고 나머지 메뉴는 거의 동일하다. 첫 메뉴가 어떻게 달라지는지는 현재 플래그에 따라 다르지 싶다.
    예를 들어서 모싸와 CEO 혹은 직원, 조직원 등 조직원 중에서도 여러가지 서로 다른 메뉴들이 존재할 수 있다. 다행히 내게는 부캐에
    2컴 구동이 가능해서 이런것들을 테스트하는 데에는 큰 문제는 없을 것으로 보인다.

24-02-05_002
    단일 함수를 어떻게 지정할지 정해야한다. 이론적으로는 SQL에 재생 목록을 저장할때에도 거기서부터 불러올 수 있는 형식으로
    만들어야할 것이다. 그리고 우선은 플래그에 대한 struct을 만들던지 객체를 만들던지 해야겠다. 아무래도 단일 함수를 담는 컨테이너를
    하나 만들고 일단은 SQL에서 재생 목록을 저장할때에는 각 함수의 id를 통해 그걸 부르도록 하는게 낫겠다. 즉, 함수와 그 id를 담는
    map을 하나 만들어서 그걸 통해 참조하는 것이다. 이 map은 static으로 만들어서 전역적으로 참조하게 하게 해야할 것. 아마도
    람다 함수로 만들어버리는것도 방법이긴 한데. 근데 이름도 있으면 좋을 것 같다. 만약 이름까지 넣을꺼면 객체로 만들어버리는게 좋지
    않을까 싶다. 배열에 넣어도 되긴 하고. 사실 배열에 넣으면 그것도 OK인데. 흠. 근데 문제는 SQL에서는 id가 1부터 시작해서
    말이지. 그렇다면 만약 벡터같은데에 넣을거면 0에 빈 객체를 넣던가 종료 함수를 넣으면 될 것이다. 그러면 1부터는 인덱싱으로 접근하게
    할 수 있으니 효율적으로 SQL로부터 데이터를 생성하는게 가능해진다. 일단은 함수 객체를 넣을 컨테이너가 필요하다. 아무래도 이것은
    객체화 시키는게 나아보인다. 왜냐하면 이게 플래그에 따라서 다르게 단일 함수를 구성해야해서 그럼. 일단은 기본적으로 단일 함수를 담을
    컨테이너를 만들어야함. 액션 객체는 그런 단일 함수들의 재생 목록을 가지고 있고, 플래그에 따라서 서로 다르게 행동되고, 그리고 이
    객체는 이제 key_pattern 객체의 데이터 멤버로 포함될거임. 일단은 SQL을 염두해 두고 있으니, 기본적으로 단일 함수들은 각 각
    고유한 id를 가져야하고. 이 목록들을 이제 SQL에서 활용해서 데이터를 만들고. 그리고 이 데이터를 통해 재생 목록을 만들어서
    action 객체를 만들고 할거임. 따라서 map<unsigned, function<void()>> 뭐 이렇게 만들어야지. key로 단일 함수의 id를
    받는거야. 그리고 단일 함수들을 전부 저장하고 이러한 단일 함수들의 반복 호출을 위해 재생 목록을 key로 구성하고 이제 재생할때에는
    그 key를 가지고 함수들을 호출해주면 될 것이다 이말이다. 근데 그렇게 하면 오버헤드가 발생하지 않을까? 근데 어차피 재생 목록을
    재생할때 만약 그냥 순수 단일 함수 객체들을 담은 목록이다 하더라도 뭔가 map으로 불러서 하는거랑 별반 차이는 없을 것이다. 물론
    이것도 물어보긴 해야겠지. 흠. 근데 그전에 함수 객체에 대해서 좀만 읽어봐야하지 않겠냐

24-02-06_000
    오늘은 좀 개발에 전념해보자. 어차피 시간은 많다. 단일 함수를 포괄하는 map이 필요하다. 그런데 이렇게 하는것이 정말로 바람직할까.
    뭐 상관은 없어보이긴 하지만. 예를들어서 메뉴가 바뀌는 지점은 최소 딜레이가 다를 수도 있지 않을까? 이런 실제 특성을 적용해서
    설계를 해야 바람직할 것이다. 그리고 만약 단일 함수더라도 어떤 매개변수를 가지는게 낫지 않을까? 근데 그럴 필요는 없어보인다.
    어차피 플래그에 대한 부분은 함수 매개변수가 아닌 외부 struct를 이용해서 거기에서 데이터를 불러와서 적절히 조작해주면 될 것이기
    때문이다. 함수 재생 목록이라는게.. 어떻게 해야 더 효율적으로 구성할 수 있을까. inline 함수를 쓰면 어떨까?

24-02-06_001
    코파일럿의 자문에 따르면 역시 inline을 쓰는게 좋아보인다. 이렇게 하면 여러개의 단일 함수들을 하나로 합쳐서 함수 호출 오버헤드를
    줄일 수 있기 때문. 주의할 점은 함수가 너무 복잡하거나 커지면 안된다. 근데 그럴리는 없는게 애초에 단일 함수 목적은 한 동작 하나를
    실행하는것이기 때문에 복잡도나 크기는 그렇게 크지는 않을 것이다. 문제는 이걸 담는 컨테이너인데.. SQL과의 호환성을 고려하면
    역시 인덱스 방식으로 저장해두고 이걸 인덱스를 통해 순차적으로 불러서 하나의 함수로 만드는 방법을 고려해 볼 수 있겠다. 또한
    주의할 점은 반드시 Debug 버전이 아닌, Release 버전으로 컴파일을 해야 제대로 inlining을 해준다는 것이다. 물론 처음에
    디버그 할때에는 괜찮은데 역시나 release 버전은 좀 다르다. optimaization을 해주느냐 안해주느냐에 따라서 inlining 적용이
    될 수도 있고 안될 수도 있기 때문. 일단은 단일 함수에 대한 function 객체를 저장하는 컨테이너를 만들던지 해야할 것 같다.
    그리고 주의할 점은 inline static을 만들면 안되는듯.

24-02-06_002
    아 그리고 이 프로젝트 github에 올리던지 해서 백업본을 만들어두는게 좋을 것 같음.

24-02-06_003
    github 올리는것도 참 여러가지 해결해야할 이슈가 많다. git을 처음 사용하는 나에게는 정말로 버겁다. 여러가지 실패를 또 겪는것이다.
    자꾸 Merge 에러가 나는데.. 대체 무엇 때문인지 알 수가 있어야지 ㅋㅋ 미치겄네. 그럼 Merge 말고 그냥 rewrite 해버리면 되지 않을까.
    하 미치겄네. 일단은 다음 명령을 통해 remote 레포지토리를 pull 하고 다시 push 해주니 되는것 같다.

    PS D:\Projects\gta_cMecro> git pull origin master
    From https://github.com/createsejin/gta_cMecro
     * branch            master     -> FETCH_HEAD
    Already up to date.
    PS D:\Projects\gta_cMecro> git push origin master
    Enumerating objects: 8, done.
    Counting objects: 100% (8/8), done.
    Delta compression using up to 12 threads
    Compressing objects: 100% (4/4), done.
    Writing objects: 100% (4/4), 549 bytes | 549.00 KiB/s, done.
    Total 4 (delta 3), reused 0 (delta 0), pack-reused 0
    remote: Resolving deltas: 100% (3/3), completed with 2 local objects.
    To https://github.com/createsejin/gta_cMecro.git
       a1e616c..9f5af50  master -> master

    문제는 Clion에서 push할때 잘 되느냐는 건데.. 계속 테스트를 해봐야할 것 같다. 어? 잘 되는것 같은데?
    역시 문제는 처음 remote 레포지토리를 pull 하지 않은 상태에서 그냥 push하다보니 뭔가 내부적으로 confilct가 일어나서
    병합 거부 문제가 발생한 것으로 보인다.

24-02-06_004
    뭐 일단은 메인컴에서도 잘되는지 테스트를 해봐야한다. 그리고 build 폴더는 포함하지 않아야하는데. .gitignore을 이용해서 제외할
    폴더들을 설정해주었다. SQL은 계속 바뀌니까 이건 레포지토리에 추가해야 작업하기 편리할 것이다. 그리고 실행 파일 경로에 img 폴더랑
    SQLite database 파일이 필요하다. inline optimaization을 위해 cmake-build-release 버전의 프로파일을 추가하고 이에 대한
    빌드 폴더를 추가해주고, 이 폴더는 역시 git에서 제외한다.

24-02-06_005
    clion에서 처음에 git repository를 설정하는건 다시 해봐야 알 것 같다. 그냥 터미널 명령어에서 하는게 나을 수도 있다.
    뭐 여러가지 방법이 있는데.. 다시 해보니 가장 간단한 방법은 그냥 Clion에서 version control 에 들어가서
    -> Share Project On -> GitHub 에서 새로운 remote repository를 만들어주는것이다. 이름만 정해주면 된다. 이렇게 하면
    아주 간단하게 알아서 원격 레포지토리를 현재 로그인한 github 계정의 레포지토리를 만들어주고 push까지 해준다. 그 후에는 일반적으로
    Clion에서 사용할 수 있는 단축키로 작업을 해주면 된다. 기본적으로 update project는 git pull 인데 Ctrl+T로 수행할 수 있고,
    commit은 Ctrl+K, push는 Ctrl+Shift+K이다. 역시 Clion이 이래서 편하다. 적어도 git 만큼은 Clion에서 작업하면 정말 간단하게
    여러가지 작업을 수행할 수 있으니 말이다. 해당 내용은 옵시디언에 자세히 기록해두었다. 뭐 별건 아닌듯. 근데 나중에 협업 프로젝트를 할때에는
    어떻게 사용해야하는지 그런부분은 나아아중에 알게 되겠지. ㅋㅋ 아무튼 Git을 쓰면 레포지토리 관리도 쉬우니 다른 컴에서 프로젝트 할때에도
    매우매우 간편하게 git pull 해서 사용하면 되니까 구지 로컬 네트워크 드라이브를 가동시켜서 그럴 필요도 없다. 게다가 자동으로 모든 사항을
    백업해주고 히스토리 기능을 이용해서 어떤 사항이 변경된건지도 보여주고, 그 시점으로 롤백하는 기능도 분명히 있을것이다. 그걸 위해서 버전
    컨트롤 시스템이 있는거니까. 아주아주 중요한 도구가 되는 샘이다. 게다가 CLion에서는 현재 레포지토리를 기준으로 저렇게 에디터에 표시를
    해주는데. 너무나도 좋은 기능이 아닐 수 없는 것이다. 지금은 비록 혼자만의 작업이라 이런 기능들의 강력함을 알 수 없겠지만, 나중에는 반드시
    협업에서는 git이 필수 중의 필수가 될 것이 확실하다. 이렇게 하면 프로젝트를 배포할때에도 매우 큰 도움이 된다. 내가 작업을 할 때마다
    모든 소스코드가 자동으로 업데이트 되고, Release 또한 자동으로 관리되니 말이다. 이것은 배포때에도 매우매우 중요한 역할을 하게 될 것으로
    보인다.

24-02-06_006
    그나저나. Action을 만들던걸 다시 진행해야하는데.. 어쨌거나 inline 함수를 활용하자는 것이다. debug 빌드 버전에서는 잘 작동되는지는
    모르겠으나. 근데 그보다도 inline이 제대로 작동함을 증명할 수 있는 방법은 없는걸까? 이건 정말로 어셈블리 코드를 봐야만 알 수 있는것 같다.
    코드 상에서 확인할 방법은 거의 없을것이다. 코드 상에서는 여전히 함수 엔티티로 존재하는 애들이고, 이걸 로컬 변수같은걸로 확인하게 할 수는
    없는거. inline 함수도 엄연한 함수이기 때문에.. 만약 정말로 확인하고 싶다면 어쩔 수 없이 그때에는 어셈블리 코드를 뽑는 방법으로 알아봐야
    할 것이다. 그것이 가장 확실하다.

24-02-06_007
    방금 그냥 프로젝트를 닫았더니 그냥 닫아진다. 즉, push나 commit 같은걸 clion 자체에서 종료할때 구지 확인을 안하고 사용자에게
    맡기는것으로 보인다. 그러니까 git을 사용할때에는 이런 점에 주의해야한다는 것이다. 그래도 다행인건 update되고 아직 push가 안된 파일은
    파란색으로 보인다. 미변경 파일은 그냥 흰색으로 보이고. 에디터에서도 어디가 변했는지 표시해준다. 색깔이 초록색인것과 파란색인건 아마도
    commit과 관련이 있어보이는데 그건 차차 알아볼 것이고. 중요한건 remote repository에 push하는게 중요한것. commit은 clion을
    종료해도 그대로 남는것 같다. 시스템을 종료하기 전까지는 그런것 같다. 그러니까 몇 가지 간단한 주의사항은 처음에 ctrl+T로 git pull을
    해서 프로젝트를 시작하고, 중간중간 ctrl+k로 commit을 해주고 업로드를 위해 마지막으로 ctrl+shift+k를 이용해 push해주는것.
    이 3가지만 주의해주면 낭낭하게 사용이 가능한듯. 그 외 여러가지 세부적인 git 사용법은 다운받은 Pro git 2판 버전의 책을 참고해서
    하나씩 배우면 될 것 같다. 앞으로도 배울게 아주아주 많을 것이다.

24-02-06_008
    그나저나 일단 단일 함수 담는 벡터를 만들자. 아마도 벡터가 인덱스 기반 랜덤 액세스는 가장 빠를 것이다. 배열기반이기 때문에.
    그리고 이 인덱스를 이용해서 SQL과의 호환되는 데이터 형식을 만드는것이다. 그래서 SQL에서는 이 인덱스를 pk로 처리해서 재생 목록에서
    이 pk를 이용해서 순서 데이터를 만들고 이 순서를 이용해서 실제 action을 실행하는것이다. 물론 함수는 모두 inlining을 지원해야한다.
    반드시 inline 키워드를 사용해주자. 나중에는 어셈블리 코드를 통해 실제로 inlining이 잘 되었는지도 확인할 생각이다.
    특히 실행 함수에서 중요한것은 여러가지 SendInput과 관련된 동작들이다. 또한 중간에 일정한 thread sleep이 필요하다. 이것이 없으면
    제대로 동작하지 않는다. 또한 이러한 액션들은 모두 별도의 실행 스레드 위에서 독립적으로 실행되어야만 한다. 그래야만 SendInput을
    제대로 실행하게 할 수 있다. 그리고 이러한 함수들은 static이 아니어야할 것이다. 또한 vector 역시 마찬가지다. 그리고 또 한가지는
    특수한 명령들, 예를들어 커맨드 모드라던가 프로그램 종료 명령은 구지 inline이 필요가 없다. 단순 호출만으로도 충분하다. 그리고 이런
    예약된 아이들을 먼저 pk를 부여해서 vector에 미리 넣어두어야 할 것이다. 그리고 중요한건 vector는 0-base이고, SQL은 1-base이다.
    그렇기 때문에 먼저 빈 람다 함수 형태의 첫번째 요소를 vector에 미리 넣어두는게 좋을 것으로 보인다. 근데 람다 함수는 애초에 inline으로
    처리되는것 같다. 그도 그럴게, 람다 함수는 익명 함수이기 때문에 inline으로 처리되는게 맞는거 아닌가. 이거에 대한 확실한 정보가 필요하다.

24-02-06_009
    중요한건 인라인 함수는 반드시 그 소스파일 내에서 사용해야만 인라이닝이 재대로 먹힌다는것이다. 그렇게 설계하려면.. 어떻게 해야할까.
    예를들어서 단일 함수 객체 또는 람다 함수를 가진 벡터를 만든다고 해도. 어쨌든간에 소스 파일 내에서 이 함수들을 불러야할 것이다.
    참조라던가 포인터로 이것을 가능케 할 수 있을 것이다. 그리고 단일 함수의 경우에는 내가 직접 조정해줘야할 것이다. 즉 이것은 처음부터
    하드코딩된 데이터로써, SQL에 적용할때에도 이것은 사용자에 의해 조작되어서는 안되는 정보이다. 반드시 미리 사전에 정의된 값을 가지도록
    SQL 및 함수의 순서를 정의해야할 것이다. 핵심은 인라이닝이다. 이 벡터를 통해 구현되는 블록이 인라이닝이 적용되어서 코드가 실행되는게
    핵심 목적이다. 그렇게 해서 성능상의 함수 호출 오버헤드를 최대한 줄이자는 것이다. 특히나 여러 키 입력이 필요한 이 프로그램에는 정말
    필요한 핵심 기능이다. 되도록이면 람다함수로 만들어도 된다. 그것이 불편하다면 함수 객체를 이용해도 된다. 어차피 둘은 만드는 방식에만
    차이가 있을뿐이며 사실 큰 차이는 없다. 나중에는 이러한 요구사항을 실제로 컴파일러가 구현했는지를 어셈블리 코드를 통해 확인할 생각이다.
    그 방법에 대해서도 여러 방면으로 알아봐야할 것이다. 핵심적인건 함수 호출 어셈블리 코드가 발견되지 않아야한다는 것이다. 또 다른 방법으로는
    여러 inline 함수를 vector 함수 객체를 통해 호출한 경우와 실제로 이 여러 함수들이 합쳐진 코드의 어셈블리 코드를 서로 비교하는 것이다.
    이렇게 하면 이 코드가 실제로 인라이닝이 제대로 되었는지를 확인할 수 있게 될 것이다. 뭐 이건 그냥 내 생각이고, 더 좋은 방법은 함수
    호출 부분에 대한 jump라던가 구체적인 어셈블리 코드를 읽을 수 있어야한다.

24-02-06_010
    메인컴에서 잘 되는지 테스트 했다. 빌드 문제없이 잘 된다. 진작에 Git을 쓸걸 그랬다. 흠. 그리고 SQLite도 역시 Clion에서 여니까
    엄청나게 편리하다. 원래는 나는 CLI 덕후라서 sqlite3.exe로 작업하려 했는데 역시나 그건 좀 아닌 것 같다. 하지만 역시 근본 sqlite3
    CLI 프로그램을 이용하는걸 좀더 고려해봐야한다. 리스트 뷰에도 익숙해질 필요가 있다. 되도록이면 sqlite3.exe를 사용하는게 좋다.
    이 CLI를 제대로 쓸 줄 알아야한다. 물론 실전에서는 필요가 없지만 그래도 나는 CLI에 익숙해지기 위해 왠만해서는 이 프로그램을 활용할까
    한다.

24-02-06_011
    소스 안에서 function을 실행해야한다. 그렇다는건 모든 작업은 action_operation.cpp 내부에서 이루어져야한다는 것이다. 이렇게
    해야만 제대로 inlining을 사용할 수 있다. 왠만해서는 그냥 이 단일 함수 벡터에는 모든 함수가 동일하게 inline으로만 이루어지게 하자.
    그리고 모두 리턴타입은 void로 하자. 이제 actions 열거 타입은 없애야할것이다. 또한 테스트로 작성한 test 임시 변수들을 제거하고
    SQL 기반으로 다시 데이터를 불러올 수 있도록 만들어야한다. 또한 KeyPattern 클래스에 Action 클래스를 넣어야한다.
    그리고 단일 함수들을 재생할 수 있는 재생 목록을 담는 vector를 action 클래스에 데이터 멤버로 만들어야할 것이다. Action 클래스는
    기본적으로 action_id, action_name 그리고 재생 목록 vector를 가진다. 또한 이 클래스는 KeyPattern 클래스와 friend 관계로
    두면 좋을 것으로 보인다. 일단은 friend는 일단 미루고 구현부터 해보자. 흠. 아마도 단일 함수는 순서에 매우 유의해야할것이다. 코멘트로
    pk를 적어가면서 코딩해야할 것 같다. 어차피 단일 함수는 미리 정해지는 하드코딩 대상이다. SQL 데이터도 미리 정해져 있어야한다. 그런데
    이걸 구지 SQL 데이터로 만들지는 모르겠다. 만약 단일 함수를 객체로 구성하면.. 문제는 inline에서 문제가 될 수 있다는 것이다. 어쨌거나
    중요한건 소스 파일 안에서 모든걸 실행해야한다. 일단은 기본적으로 테스트용 단일 함수를 구성하는데.. 여기서 바로 SendInput을 구현할 수도
    있다. 근데 문제는 SendInput의 경우에는 scanCode를 알아내야해서. 이걸 알아내는 기능을 구현해야할 것이다. 되도록이면 단일 함수는
    변수도 소스 내에서 해결하도록 하자. 객체가 아닌 순수한 소스 기반으로 해야한다는 것이다. 그래야만 컴파일러가 inline을 제대로 구현할 수
    있을 것이다. 그리고 SQL에서는 이들을 식별하기 편리하도록 name 칼럼을 넣자.

24-02-06_012
    그런데 만약 이걸 action 객체에서 구현하면 이걸 실제로 function 재생 벡터로 기능을 구현하면 이게 제대로 inline이 되는건지를
    확실하게 해야할 것이다. 그러니까 action_operator.cpp 내에서 함수 구현이 이루어져야할 것이다. 외부적으로는 콜백 될 수 있지만
    내부적으로는 반드시 action_operator.cpp 내에서 실제 함수가 동작해야한다. 그리고 inilning이 실제로 됐는지를 테스트하기 위해
    어셈블리 코드를 뽑을 수 있도록 해야한다. 실제로 어셈블리 코드를 봐야한다는 것.

24-02-06_013
    일단은 간단히 테스트를 해봐야한다. 그리고 SQL을 다룰 수 있는 CLI 인터페이스를 구현해야할 것 같다. 기본적으로 내가 개발에서 사용할
    여러가지 SQL 입출력 인터페이스를 구현할 생각이다.

24-02-06_014
    역시나 여러가지 문제점에 봉착했다. inline을 구현하기 위해 템플릿을 썼었는데 여기에 문제가 생긴것. 그냥 함수 포인터로 구현해버렸다.
    이게 가장 속 편한듯. 템플릿은 나중에 따로 공부를 해야할 것 같다.

24-02-06_015
    일단 구동 테스트는 완료했다. 문제는 어셈블리 코드를 분석해야해서 아마도 아예 따로 test 디렉터리에서 이 부분만 어셈블리 코드를 뽑아봐야
    할것 같다. 근데 솔직히 말하면 inline으로 얻을 수 있는 이득은 사실상 매우 적다. 게다가 그런 부분은 어차피 컴파일러가 알아서 한다.
    inline이 아닌 함수도 컴파일러의 결정에 따라 inline으로 처리하는 경우도 있다. 그러니까 이 부분은 내가 명시적으로 inline을 하도록
    할 수가 없는 부분이기 때문에 그냥 간단하게 functional 객체로 처리하는게 가장가장 이롭다. 설령 inline화가 안된다고 하더라도
    그 부분에서 발생하는 성능 오버헤드는 매우 적은 정도이기 때문에 아무런 상관이 없을 것이다. 걱정할 필요가 전혀 없다. 그냥 편하게 하자.
    어차피 C++이다. C++이니까 그정도는 새발의 피다.

24-02-06_016
    간단히 SQL 데이터 베이스 파일을 만들어줬다. 내일부터는 본격적으로 action을 구현해나가자.

24-02-07_000
    어차피 상호작용 메뉴 기반으로 만들거면 그냥 상호작용 메뉴를 아예 객체화해서 그걸 이용해서 액션을 템플릿 형식으로 찍어버리면 되잖아.
    어차피 이 매크로의 목적은 상호작용간의 이동임. 그러니까 먼저 필요한건 상호작용 메뉴들의 집합이고. 이게 어떻게 변화하는지를 추적하고
    그 변화에 따라 현재 액션을 실행했을때 어떤 동작을 할건지 정해버리면 되지. 일단은 단일 액션을 실제로 동작이 가능한 SendInput을
    구현해야하는것도 중요함. 그리고 커맨드 모드 완성해야해. 커맨드 모드 들어가면 user input에서 블로킹 걸려서 gui 먹통 되는것도
    고치던가 해야함.

24-02-07_001
    커맨드 모드로 들어갈때 gui를 어떻게 할건지 구체적으로 동작을 만들어줘야함. 예를들어서 커맨드 모드 상태에서 close를 누를때가 문제임.
    이때 정상적으로 종료되게 해야하는데 문제는 command 모드에서 getline 블로킹 걸려서 event가 먹통되버림. 근데 이건 어쩔 수 없는
    문제 아니냐. 아니 getline 블로킹을 무슨수로 풀어?

24-02-07_002
    그냥 자연스럽게 마지막에 엔터를 눌러서 끌 수 있게 해버렸다.. 그거 말고는 다른 방법을 쓰자니 너무 복잡해지고 내가 다룰 수 있는 수준은
    아니었다. getline을 해제하는 방법은 스트림 입력 뿐이다. 그게 아니면 non-blocking 방법을 써야하는데 그냥 엔터키 한번만 더 누르면
    되는거고. 어차피 CLI는 나만 쓰는 용도다. 실제 User가 쓰는 기능이 절대 아니기 때문에 상관이 전혀 없다.

24-02-07_003
    커맨드 모드에서 exit 기능을 만들어버리자. exit를 하면 gui도 함께 종료되면서 프로그램이 종료되게.

24-02-07_004
    CLI11이 문제가 있다. 자꾸 블로킹이 걸리는데 대체 왜 그러는건지 알 수가 없다. 그냥 CLI는 내가 자체적으로 직접 만들까 한다. 어차피
    CLI를 잘 만드는것도 하나의 능력이기 때문에 이것만큼은 내가 직접 만들어버릴 생각이다. 핵심은 SQL 다루는 명령어들을 잘 넣어야할듯.
    그러려면 파싱을 잘 해야하는데.. 흠.. SQL 출력문도 만들거냐. 그러려면 포맷팅을 잘해야하는데 흠흠.. ㅋㅋ 근데 왠만하면 그냥 한 줄 커맨드로
    하자. 그리고 왠만해서는 SQL도 그냥 sqlite3.exe에서 처리하는게 맞음. 그나저나 이제 진짜 action 구현해야지.

24-02-07_005
    그. SQL 테이블이나 짜보자. 일단 key_pattern. 이거 어케 할거임. pk랑 id랑 name정도 가지게 하고. 흠. 그 다음에는
    combine_key는 어떻게 할거임? 레코드를 어떻게 들어가게 할건지 정해야지. 그러니까 각 Combine 마다 한 묶음씩 id를 가지게 해야할듯.
    그리고 이걸 중복 검사해서 예를 들어서 {X, C}가 이미 있으면 그걸 갖다가 쓸 수 있게 하는거야. 그리고 Combine 키는 그 map을 통해서
    Text를 읽어서 keyCode 열거체로 변환시키는거지. 그 다음에 combine_key 객체에 들어가는거야. 아니면 그냥 키코드를 전부 다 입력시켜 그냥
    그 다음에 그걸 조합해서 만들면 되지 그까짓거. 그 다음에 테이블만 새로 만들어서 sequence_num, key_code 뭐 이런식으로 구성해서 만들면
    되지. 물론 키코드 입력은 수동으로 하면 절대 안되고 ㅋㅋ 당연히 SQL api로 해버리면 되지. 그게 뭐 어렵다고. key_code table만 만들자.
    pk, key_value, key_name 정도면 될 것 같은데. table 이름은 key_code로 하면 되겠네. 근데 pk도 왠만하면 table 이름 들어가게 구성
    하는게 나중에 좋음. 즉, key_code_pk 뭐 이런식 기존 테이블도 좀 드롭 해주자.

24-02-08_000
    내 생각에는 그냥 상호작용 메뉴 다 따버리는게 나아보임. 그래서 그걸 기반으로 어디서 어디로 움직일건지 하는 그런 매커니즘을 만들어두면
    나중에 액션 만들때 개 편할듯. 그리고 SQL 이니 뭐 JSON이니 했는데 나는 그냥 SQL 쓸라고함. 어차피 나는 SQLite3 덕후라서 어쩔 수
    없음. JSON은 파싱도 해야하고. XML도 마찬가지임. 근데 솔직히 그냥 설정에는 JSON이나 XML이 더 좋은건 맞음. 근데 그냥 SQL 쓸래.
    이걸로 그냥 데이터 관련된거 싹다 만들거임. 근데 이것도 좋은 방법은 아니다. 정말로. 되도록이면 XML 같은거도 써봐야함. SQL만 쓰겠다는건
    솔직히 좀 그것도 웃긴거임. 고작 몇 줄 설정 하겠다고 table 하나를 만드냐고. 근데 나는 되도록이면 그냥 SQL 쓸 생각임.

24-02-08_001
    그래서 key_code 필요하냐고? 글쎄. 근데 만들어주면 좋을것 같긴 함. 어차피 입력 매커니즘은 따로 만들어야하고. key_code 만들어놓으면
    key_value 가지고 데이터 베이스 구성하는게 가능하니까 만들면 좋지. 일단 그거부터 할까.

24-02-08_002
    key_code 넣는건 성공적으로 된 것 같다. 그리고 단일 함수도 그냥 인덱스 0번부터 넣어도 상관없을듯. 어차피 pk랑 id는 별개값으로 취급할거임.
    그리고 여기에서 중요한 기능들을 함수화 시켜서 나중에 재사용할 수 있도록 해버리자. test에 있는 코드도 재사용 코드로 만들어서 써야할듯.

24-02-08_003
    여러가지 SQL 함수들을 간편하게 재사용할 수 있도록 헬퍼 함수로 정리했다. 테스트까지 완료.

24-02-08_004
    이제 뭐할까. combine key나 만들자. 차근차근 만들어서 테스트용으로 key_pattern 까지 sql로 구현하도록 하자. 일단은 시작은 combine
    key 부터. 이것도 간단함. 근데 이것도 부모-자식 테이블 있어야할것 같음. 그루핑 해야해서. 근데 SQL에서는 구지 combine key는 구현할
    필요가 없을텐데. 그냥 쭉 나열해도 상관 없어. 중요한건 pattern_id임. 이걸로 묶으면 되고. 슬롯 넘버는 1, 1, 2 이런식으로 나열하면 됨.
    그리고 이것들을 가져와서 유효성 검사하는거 만들어야함. 그건 아마 프로그램 코드 내에서 해결해야할거다. 그럼 일단은 key_pattern table
    만들어야지. 그리고 combine key들을 담는 combine_key table도 만들어야함. pattern_id, slot, key_code_pk 이렇게. 어차피
    데이터는 무조건 정규화 해야하고. 나중에 확인하는거는 view 만들어서 확인하면 됨. 임시 테이블은 메모리 db 쓰거나 virture table 쓰면
    되는데 virture은 기능이 제한적이니까 메모리 db 쓰는게 나음. 어쨌거나 대부분 view로 다 해결돼. 조회 목적으로 만드는거면 view 만으로도
    그냥 가능함. 문제는 table modify 할때 view를 drop 했다가 다시 create 해야하는게 짜증나서 table modify는 그냥 아예 스크립트를
    미리 짜놓고 그걸 .read 하는 식으로 운용하는게 편함.

24-02-08_005
    view는 어쩔 수 없음. 내부적으로 table modify 할 때 select 문으로 insert하면 그때 트리거 발동되면 그 쿼리 때문에 에러남. 테이블
    구조가 바뀌었으면 그럼. 그래서 만약 트리커 뷰 있으면 어쩔 수 없이 그 뷰들을 다 드롭하고 그 다음 테이블을 만든 다음에 다시 create
    해줘야함. 이건 어쩔 수 없음. 아. 그리고 일단은 상호작용 메뉴 다 따버리자. 그거 먼저 해야해.

24-02-08_006
    메뉴 아이템에 대한 데이터를 구축해버려야함. 그래야 내가 편하다. 그리고 각 메뉴에서 각 메뉴까지 가는 방법을 계산하는 알고리즘을 하나
    만들면 일이 쉬워질 거다. 매우. 일단은 MenuNode 구조체를 만들어서 연산이 가능하도록 만들었다. 그런데 문제는 상위, 하위 노드로의
    계산 알고리즘을 어떻게 구현하느냐인데.. ㅋㅋ 이건 좀.. 근데 애초에 데이터를 보면 부모-자식 관계가 있잖아. 그걸 이용하면 되지 않을까.
    근데 진짜 이건 일단 데이터를 구성해보고 생각을 해봐야할것 같고 코파일럿에게도 자문을 해봐야겠다.

24-02-08_007
    생각을 해보니 이건 대박이다. 만약 메뉴 아이템을 서로 왔다갔다 할 수 있는 알고리즘이 있으면 매크로 구현이 매우 쉬워질 뿐만 아니라
    더 정확해질 것이다. 예를들어서 구체적인 여러 행동들의 조합들을 만드는게 행동 위주가 아니라 메뉴 위주로 바뀌면 더욱더 어마어마한
    기능상으로는 정말 더할 나위 없는 매크로가 될 것이다. 내가 왜 이걸 생각 못 했을까. 아무튼. 근데 문제는 node를 탐색하는 알고리즘과
    탐색 과정에서 각 노드로 넘어갈때 어떻게 넘어갔는지 등이 상세하게 데이터에 저장되어서 그걸 활용해서 메뉴간 이동을 추적해야한다.
    이것은 새로운 도전거리일 것이다.

24-02-08_008
    SQL db를 관리하는 클래스를 만들어야할 것 같다.

24-02-08_009
    아무래도 메모리 DB를 쓰는건 자제해야겠다. 로컬 변수가 아닌 전역 변수나 클래스 멤버 변수로 선언하고 이걸 file stream에서 부터
    읽어서 할당하면 나중에 문제가 반드시 생긴다. 아마도 file stream에서 읽어온 데이터가 스코프를 벗어나면 해제된다거나 하는 문제가
    있었는데, 이것을 변수에 저장해서 하려고 해도 out of memory 문제가 생겼다. 이런 문제는 file stream에 대한 아주 정확한 이해가
    필요해보인다.

24-02-09_000
    잠에 자려고 침대에 눕고나서 얼마뒤에 갑자기 생각이 떠올랐다. 설마 이 클래스가 스택에 선언되서 그런건가? 동적 할당 하면 out of memory
    문제를 피할 수 있잖아! 라고 말이다. ㅋㅋ 맞는것 같다. 지금 현재 이 클래스는 싱글턴으로 스택에 선언되어있다. 즉, 메모리 동적 할당되지
    않았다는것이다. 그리고 어제도 예상대로 file을 열고 그것을 memdb에 다시 할당하는것 같은데 문제는 file이 함수 스코프 out 때문에
    유효하지 않게 되서 문제가 계속 생긴것 같다라는것. 그래서 file 스트림 부분을 모두 멤버 변수로 따로 저장해야한다는 것이다. 그러니까
    오늘 할 일은 SQLManager를 동적 할당으로 instance를 생성해놓아야 한다는 것이다. 어차피 이걸 외부에서 새로 만드는 경우는 없으니까
    대신 만약 unique_ptr로 처리하려면 생성자와 소멸자를 public으로 해야한다. 아니면 그냥 동적 할당한 뒤에 프로그램 종료 시점에서
    직접 메모리를 해제하는 방법. 둘 중 하나를 해야하는데. 그리고 어제 테스트 해보니 소멸자는 잘 불러진것 같았다. 그리고 어차피 모든
    프로그램이 종료되면 메모리는 시스템에 자동으로 회수하게 되어있다. 그래도 메모리 해제 부분을 잘 컨트롤 하거나 그냥 unique_ptr로
    만들어야할 것이다.

24-02-09_001
    됐다. ㅋㅋ 역시 내 생각대로다. 흠 근데 문제는 소멸자가 제대로 잘 안불러지는것 같다? 그럼 그냥 소멸시키는 코드를 public 메서드로
    만들어서 직접 소거해주면 되지 않을까? 그리고 소멸자를 불러버리면 되잖아. 근데 더 좋은 생각은 이걸 그냥 main에다가 instance를
    동적으로 할당한 다음에 싱글턴 패턴으로 사용하지 않고 그냥 unique_ptr로 동적 할당한 다음에 알아서 소멸되도록 하는거다. 그게 더
    좋아보이지 않는가? 내 생각이지만, 싱글턴 패턴은 문제가 생성자 소멸자가 private라서 스마트 포인터를 못 쓰기 때문에 만약 동적
    할당이 필요하면 싱글턴 패턴을 뭐 바꾸던가 해야할것 같은데. 아니면 생성자 소멸자만 그냥 public으로 바꾸던가. 근데 그렇게 하면..
    싱글턴 패턴이 더이상 아니다. 그럴 바에는 그냥 이걸 일반 객체로 다루는게 나아보인다.

24-02-09_002
    객체를 일반 객체로 지정하고 싱글턴 패턴을 없앴다. 그리고 이 클래스의 경우에는 sqlite3*이라는 동적 할당된 데이터 멤버가 존재하므로
    이동 연산자 같은걸 따로 구현해야하긴 하다. 그러나 그것은 복제 인스턴스 생성이나 인스턴스 이동 등이 필요할때만 작업해주면 되니까
    상관은 없다. 다만 이 인스턴스를 반드시 extern으로 선언해야한다는 것이다. 이전에는 inline static으로 선언해버려서 문제가 이 헤더를
    포함하는 소스파일이 만약 3개라면 그 소스 파일에서 각각 3개의 독립적인 인스턴스를 생성해버린다는게 문제였다. 이것을 extern으로
    선언하니 문제가 해결됐다. 또한 static은 extern과 배타적인 키워드라는걸 알 필요가 있다. static은 내부 링크를 제공하며, extern은
    외부 링크를 제공한다. inline static은 외부 링크를 지원하는것으로 보이지만 되도록 쓰지 않는게 좋다. 특히 프로그램 내에서 글로벌 변수를
    지정할 떄에는 반드시 inline static을 배제하고 extern을 쓰는게 좋다. 이렇게 해야만 변수가 하나만 만들어지기 때문이다.
    extern으로 변수를 헤더 파일에 선언해주고 초기화는 소스파일에서 해주는게 좋다.

24-02-09_003
    아마도 이 클래스와 비슷한 문제. 즉, 동적 메모리 할당된 객체 문제 때문에 CLI11 app에서도 문제가 발생했을 여지가 높다. 이러한
    복잡한 라이브러리는 그 클래스 내부에 동적 할당된 리소스가 거의 무조건 있을 것이라고 생각할 수 있다. 따라서 이를 스택에 선언하면
    동적 메모리 할당된 데이터 멤버같은 애들에서 문제가 생길 여지가 있다. 따라서 이러한 app은 선언시 반드시 스마트 포인터를 통해
    동적으로 할당해야한다. 그렇게 하면 문제가 없어질 것이다.

24-02-09_004
    그러므로 이제 commander.h에서 extern std::unique_ptr<CLI::App> commander_app; 이렇게 선언하고 소스파일에서
    make_unique<CLI::App>() 이렇게 초기화해주면 된다. 그러면 이제 이 클래스는 메모리가 동적으로 할당되게 된다.
    반드시 이렇게 만들어야한다. 그래야만 스택 오버플로우나 메모리 과소 문제, 동적 메모리 할당 문제에서 자유로워진다.
    다시 한번 CLI11을 사용해서 커맨드라인 인터페이스를 조금 구현해보자.

24-02-09_005
    아무래도 그냥 CLI11은 사용하지 않는게 좋을것 같다.. 자꾸 예측할 수 없는 행동이 자꾸 생긴다. 아무래도 CLI는 그냥 내가 직접
    만드는게 나을것 같음.. ㅡㅡ..

24-02-09_006
    이제 메모리 데이터 베이스는 문제없이 잘 작동하고, 닫는것도 이제 알아서 한다. 이제 disk 데이터 베이스에 쓰기하는 기능 만들고
    테스트 해보자. 그리고 메뉴 아이템 따는것도 진행해야 할것 같다.

24-02-09_007
    코드를 조금 다루었다. 메뉴 아이템 직접 추가하는게 좀 고역이긴 하다. 그리고 메뉴라는데 좀 여러가지 타입을 나눠서 해야할것 같음.
    예를 들어서 이 메뉴는 왼쪽 오른쪽으로 이동 가능한지 아닌지, 메뉴 아이템이 바뀌는 타입인지 아닌지 등이 필요함. 바뀔때에는 뭘로 바뀌는지 등
    아무튼 메뉴 직접 다루려면 메뉴 행동에 대해서 묘사할 수 있도록 데이터 구조를 만들어야지.

24-02-09_008
    커맨드 모드로 바로 진입하게 하는 기능을 만듬. 그리고 또 뭔가 이상함 커맨드 모드에서 GUI X 버튼 눌렀을때 메세지가 안뜬다. 얼른 수정하자.























